#!/bin/sh

log()
{
    echo "$0: $1" >/dev/console
    logger -s "$0: $1"
}

uptime_in_seconds()
{
	cut -d'.' -f1 /proc/uptime
}

if [ "$1" = "boot" ]; then 
    log "boot is set - non interactive mode"
    ISBOOT=ja
    shift
fi 


[ "${USER:-root}" = "root" ] || {
	log "[ERR] user = $USER: seems we are in cross compiling stage?"
	exit 0
}

if [ -e /tmp/LOCKFILE_APPLY ]; then                                                                                                     
        log "abort: /tmp/LOCKFILE_APPLY exists"                                                                                         
        exit 1                                                                                                                          
else                                                                                                                                    
        touch /tmp/LOCKFILE_APPLY                                                                                                       
fi             

find_all_strings_in_dmesg()
{
	local error

	while [ -n "$1" ]; do {
		if fgrep -q "$1" "$DMESG"; then
			error=0
		else
			error=1
		fi

		shift
	} done

	return $error
}

hwprobe()
{
	local machine="$1"

	case "$machine" in
		"D-Link DIR-300 RevA1")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"IP17xx: Found IP175C at 0:00"
		;;
		"Ubiquiti Nanostation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2315 chip found (MAC: 0x86, PHY: 0x48)" \
							"lpj=918528"
		;;
		"Ubiquiti PicoStation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"lpj=917504"
		;;
		"Ubiquiti Nanostation5")
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k: phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=898048"
		;;
		"Ubiquiti PicoStation5"|"Ubiquiti Litestation5")	# nanostation5 -> lpj differs
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=899072"
		;;
		*)
			false
		;;
	esac

	return $?
}

DMESG="/tmp/dmesg.boot"
[ -e "$DMESG" ] || {
	dmesg >"$DMESG"
}

uboot_getvar()
{
	local var="$1"

	strings '/dev/mtd0' | grep ^"${var}=" | cut -d'=' -f2
}

try_device()
{
	I=$(( ${I:=0} + 1 ))	# global_var

	case "$I" in
		 1) HARDWARE="Linksys WRT54G/GS/GL" ;;		# brcm47xx
		 2) HARDWARE="Ubiquiti Bullet M" ;;		# ar71xx
		 3) HARDWARE="TP-LINK TL-WR1043ND v2" ;;	# ar71xx
		24) HARDWARE='TP-LINK TL-WR1043ND' ;;		# ar71xx
		 4) HARDWARE="Buffalo WHR-HP-G54" ;;		# brcm47xx
		 5) HARDWARE="SPW500V" ;;			# speedport w500v / aldi router
		 6) HARDWARE="ASUS WL-HDD" ;;			# brcm47xx
		 7) HARDWARE="ASUS WL-500g Premium V2" ;;	# brcm47xx
		 8) HARDWARE="ASUS WL-500g Premium" ;;		# brcm47xx
		 9) HARDWARE="Dell TrueMobile 2300" ;;		# brcm47xx // nvram set ModelId=WX-5565 commit
		10) HARDWARE="Ubiquiti RouterStation Pro" ;;	# ar71xx
		11) HARDWARE="4G Systems MTX-1 Board" ;;	# au1000 / meshcube
		12) HARDWARE="Buffalo WZR-HP-AG300H" ;;		# ar71xx
		13) HARDWARE="Ubiquiti Nanostation M" ;;	# ar71xx
		14) HARDWARE="Seagate FreeAgent DockStar" ;;	# kirkwood
		15) HARDWARE="TP-LINK TL-WR841N/ND v7" ;;	# ar71xx
		16) HARDWARE="SPW500V" ;;			# brcm63xx / Targa WR 500 VoIP
		17) HARDWARE="TP-LINK TL-WDR3600/4300/4310" ;;	# ar71xx
		18) HARDWARE="TP-LINK TL-WR703N v1" ;;		# ar71xx
		19) HARDWARE="TL-WDR4900 v1" ;;			# mpc85xx / vendor: tplink
		20) HARDWARE="TP-LINK TL-WR841N/ND v8" ;;	# ar71xx
		21) HARDWARE='PC Engines ALIX.2 ' ;;		# x86
		22) HARDWARE='Asus WL500GP V1' ;;		# brcm47xx -> rename
		23) HARDWARE='La Fonera 2.0N' ;;		# ramips_24kec
		25) HARDWARE='Seagate GoFlex Net' ;;		# kirkwood
		26) HARDWARE='TP-LINK Archer C7' ;;		# ar71xx
		*)
			HARDWARE=
			return 1
		;;
	esac
}

if   hwprobe "D-Link DIR-300 RevA1"; then
	HARDWARE="D-Link DIR-300 RevA1"
elif hwprobe "Ubiquiti Nanostation2"; then
	HARDWARE="Ubiquiti Nanostation2"
elif hwprobe "Ubiquiti Nanostation5"; then
	HARDWARE="Ubiquiti Nanostation5"
fi

[ -z "$HARDWARE" ] && {
	while try_device; do {
		fgrep -q "$HARDWARE" "$DMESG" && break
	} done
}

if [ -n "$HARDWARE" ]; then
	case "$HARDWARE" in
		'TP-LINK Archer C7')
			. /tmp/loader
			[ $( _system flash_size ) -eq 16384 ] && {
				HARDWARE="$HARDWARE v2"
			}
		;;
		'Asus WL500GP V1')
			HARDWARE='ASUS WL-500g Premium'
		;;
		"4G Systems MTX-1 Board")
			HARDWARE="T-Mobile InternetBox"	# also: '4G MeshCube'
		;;
		"SPW500V")
			HARDWARE="Speedport W500V"	# also: 'Targa WR 500 VoIP'
		;;
		"TL-WDR4900 v1")
			HARDWARE="TP-LINK $HARDWARE"
		;;
		"Ubiquiti Bullet M")
			ip address show | fgrep -q " 00:27:22:" && {
				log "is it a 'Ubiquiti Picostation M2'?"
				# HARDWARE="Ubiquiti Picostation M2"
			}
		;;
		'Seagate GoFlex Net')
			[ "$( uboot_getvar 'machid' )" = '0xd0a' ] && {
				# see https://dev.openwrt.org/ticket/14303
				HARDWARE='Seagate GoFlex Home'
			}
		;;
	esac

elif hwprobe "Ubiquiti PicoStation2"; then		# Atheros-Platform: http://www.ubnt.com/picostation
	HARDWARE="Ubiquiti PicoStation2"
elif hwprobe "Ubiquiti PicoStation5"; then		# Atheros-Platform: http://www.ubnt.com/picostation5
	HARDWARE="Ubiquiti PicoStation5"
elif grep -sq ^'loco-m-xw'$ '/tmp/sysinfo/board_name'; then
	if iw phy phy0 info | grep -q '5180 MHz'; then
		HARDWARE="Ubiquiti Nanostation loco M5"
	else
		HARDWARE="Ubiquiti Nanostation loco M2"
	fi
elif [ -e "/etc/HARDWARE" ]; then
	log "could not detect hardware, trying /etc/HARDWARE"
	read HARDWARE </etc/HARDWARE
else
	log "could not detect hardware, please enforce manually with a text in /etc/HARDWARE - abort"

	[ "$1" = "help" ] || exit 1
fi

HARDWARE="$( echo "$HARDWARE" | sed 's/[ ]*$//' )"	# strip trailing whitespace (see alix2)

log "detected: '$HARDWARE' and wrote to '/etc/HARDWARE' for later monitoring"
echo "$HARDWARE" >"/etc/HARDWARE"

case "$HARDWARE" in
	"Linksys WRT54"*|"Buffalo WHR-HP-G54"|"Dell TrueMobile 2300")
		rm /etc/modules.d/*usb*
	;;
esac



merge_options()
{
  local FIRST=$1        # e.g. meshwizard values
  local SECOND=$2       # e.g. system values from previous install
  local THIRD=${3:-""}  # e.g. default value we want to have else

  if [ -n "$FIRST" ]; then
    echo "$FIRST"
  elif [ -n "$SECOND" ]; then
    echo "$SECOND"
  else
    echo "$THIRD"
  fi

}

SIM_ARG1="$( merge_options "$1" $( uci -q get meshwizard.community.ipschema ) $( uci -q get system.@profile[0].name | cut -d'_' -f1 ) )"
SIM_ARG2="$( merge_options "$2" $( uci -q get meshwizard.community.wifimode ) $( uci -q get system.@profile[0].name | cut -d'_' -f2 ) )"
SIM_ARG3="$( merge_options "$3" $( uci -q get meshwizard.community.nodenumber ) $( uci -q get system.@profile[0].nodenumber ) )"

has_default_route ()
{
	[ -e /sbin/route ] && {
		route | grep -q ^default && return 0
	}

	[ -n "$( ip route list exact 0.0.0.0/0 )" ] && {
		return 0
	}

	return 1
}

has_default_route && {
	[ "$( uci -q get network.wan.proto )" = "dhcp" ] && {
		SIM_ARG4="dhcp"		# auf masq=1 testen?
	}
}

#######################################
#
# enforcing a profile (uncomment!)
#
#SIM_ARG1="olympia"
#SIM_ARG2="adhoc"
#SIM_ARG3=2		# 2,3,4,...,n (number 1 is reserved for vpn-server)

#[ "$SIM_ARG3" = "2" ] && SIM_ARG4="dhcp"
#
#######################################



[ -n "$SIM_ARG1" -a -n "$SIM_ARG2" -a -n "$SIM_ARG3" -a -z "$PROFILE_MODE" ] && {
	echo "detected already set values:"
	echo "INSTALLATION: $SIM_ARG1"
	echo "PROFILE_MODE: $SIM_ARG2"
	echo "NODENUMBER: $SIM_ARG3"
	echo "GATEWAY: $SIM_ARG4"
	echo

	[ "$ISBOOT" = "ja" ] || {
		echo "press <enter> to continue/reapply these values or strg+c to abort"
		read 
	}

	INSTALLATION=$SIM_ARG1
	PROFILE_MODE=$SIM_ARG2
	NODENUMBER=$SIM_ARG3
	GATEWAY=$SIM_ARG4
}

[ -z "$NODENUMBER" -o -z "$INSTALLATION" -o -z "$PROFILE_MODE" -o "$INSTALLATION" = "?" ] && {
	echo "Usage: $0 <installation> <adhoc|ap|hybrid> <nodenumber> <gateway|dhcp|empty>"
	echo
	echo "		 installation = {"

	grep ^"	[a-z0-9|]*)" "$0.definitions" | sed 's/)//g' | while read line; do {
		echo "					$line"
	} done

	echo "				}"

	exit 1
}

case "$PROFILE_MODE" in
	ap|apB|apC|adhoc|ap5|adhoc5|hybrid)
		log "[OK] mode '$PROFILE_MODE' is valid"
	;;
	*)
		log "abort, mode must be one of [ap|adhoc|hybrid]"
		exit 1
	;;
esac

password_was_never_set()
{
	grep -qs '^root:[!x]\?:' /etc/shadow
}

password_set()
{
	local PASSWORD="${1:-admin}"
	local credentials

	password_was_never_set || {
		log "password_set() ignore call, password already set"
		return 0
	}

	log "password_set() to '$PASSWORD'"
	sh -c "echo '$PASSWORD'; sleep 1; echo '$PASSWORD'" | passwd>/dev/null 2>&1
	log "password_set() [OK]"

	if [ "$INSTALLATION" != "ffweimar" ]; then	#no web server authentication on weimarnetz routers
		echo "/cgi-bin/:root:$PASSWORD" >/etc/httpd.conf

		for credentials in "$HTTPD_CREDENTIALS"; do {
			echo "/cgi-bin/:$credentials" >>/etc/httpd.conf
		} done
	fi

	which dropbear >/dev/null || {
		log "missing dropbear, allowing telnet login permanentely in /bin/login.sh"
		sed -i 's/exit 0/# exit 0/' /bin/login.sh
	}
}

case "$PROFILE_MODE" in
	hybrid)
		PROFILE_MODE="adhoc"
		. ${0}.definitions
		PROFILE_MODE="hybrid"

		[ -z "$SSID_ENFORCED" ] && {
			SSID_ENFORCED="$INSTALLATION $NODENUMBER"
		}
	;;
	*)
		. ${0}.definitions
	;;
esac

[ -z "$CHANNEL" ] && CHANNEL=1

case "$HARDWARE" in
	"Ubiquiti Bullet M")
		[ -n "$TXPOWER" ] && {
			# https://dev.openwrt.org/browser/trunk/package/iwinfo/src/iwinfo_lib.c#L31
			TXPOWER=$(( $TXPOWER - 12 ))
		}
	;;
esac

#get old hostname or hostname set in system config
OLD_HOSTNAME="$( uci -q get meshwizard.system.hostname )"
[ -z "$OLD_HOSTNAME" ] && {
	OLD_HOSTNAME="$( uci -q get system.@system[0].hostname )"
}

case "$OLD_HOSTNAME" in
	OpenWrt|lede|"")
		OLD_HOSTNAME="${INSTALLATION}-${PROFILE_MODE}-${GATEWAY}-${NODENUMBER}"
		log "using new hostname $OLD_HOSTNAME"
	;;
	*)
		log "leaving hostname $OLD_HOSTNAME"
	;;
esac

echo "$OLD_HOSTNAME" >/proc/sys/kernel/hostname

_config_cron () 
{
	echo "* * * * * . /usr/sbin/cron.minutely; . /tmp/loader; _watch switch_linkstatus" | crontab -
}

_config_system ()
{
	local NODE="$1"

	echo "${OLD_HOSTNAME}" >/proc/sys/kernel/hostname

	touch /etc/config/system

	#system section of system
	uci set system.@system[0].hostname="$OLD_HOSTNAME"
	uci set system.@system[0].timezone="${TIMEZONE:-GMT0}"
	uci set system.@system[0].cronloglevel="9"
	uci set system.@system[0].log_size="16"
	if [ "$INSTALLATION" = "ffweimar" ]; then       #restore all settings in profile ffweimar 
                uci set system.@system[0].noswinstall="1"
	fi	
	# set location only when data is fresh from meshkit, else leave all values
	[ -n "$FRESHMESHKIT" ] && {
		[ -n "$( uci -q get meshwizard.system.conloglevel )" ] && {
			uci set system.@system[0].conloglevel="$( uci -q get meshwizard.system.conloglevel )"
		}
		[ -n "$( uci -q get meshwizard.system.latitude )" ] && {
			uci set system.@system[0].latitude="$( uci -q get meshwizard.system.latitude )"
		}
		[ -n "$( uci -q get meshwizard.system.longitude )" ] && {
			uci set system.@system[0].longitude="$( uci -q get meshwizard.system.longitude )"
		}
		[ -n "$( uci -q get meshwizard.system.location )" ] && {
			uci set system.@system[0].location="$( uci -q get meshwizard.system.location )"
		}
	}
	
	#ntp section of system

	uci delete system.ntp
	uci set system.ntp="timeserver"
	uci add_list system.ntp.server="0.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="1.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="2.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="3.openwrt.pool.ntp.org"
	uci set system.ntp.enable_server="0"

	#weblogin section of system

	local hide_lang="#"	# default-lang

	uci set system.weblogin="weblogin"

	[ -z "$( uci -q get system.weblogin.enabled )" ] && {
		uci set system.weblogin.enabled="0"
	}
	[ -z "$( uci -q get system.weblogin.email2owm )" ] && {
		uci set system.weblogin.email2owm="0"
	}
	uci set system.weblogin.namespace="capital_citys_de"
	[ -z "$hide_lang" ] && {
		uci set system.weblogin.adminlang="en"
	}
	# restrict access to wan subnet 
	[ -z "$( uci -q get system.weblogin.restrict_local )" ] && {
	    uci set system.weblogin.restrict_local="1"
	}

	#profile section of system
	uci set system.profile="profile"
	uci set system.profile.name="${INSTALLATION}_${PROFILE_MODE}"
	uci set system.profile.nodenumber="$NODE"
	uci set system.profile.ipsystem="${IPSYSTEM:-ffweimar}"

	#monitoring section of system
	uci set system.monitoring="monitoring"
	uci set system.monitoring.url="http://intercity-vpn.de/networks/${INSTALLATION}"

	#fwupdate section of system
	uci set system.fwupdate="fwupdate"
	uci set system.fwupdate.url="http://weimarnetz.de/freifunk/firmware"
	if [ -z "$( uci -q get system.fwupdate.mode )" ]; then	# if not set make it stable
		uci set system.fwupdate.mode="stable"
	fi

	#admin section of system
	uci delete system.@admin[0]
	uci set system.admin="admin"
	uci set system.admin.location="$( contact location )"
	uci set system.admin.latlon="$( contact latlon )"
	uci set system.admin.mail="$( contact mail )"
	uci set system.admin.name="$( contact name )"
	uci set system.admin.phone="$( contact phone )"
	uci set system.admin.neturl="$( contact neturl )"

	#vpn section of system
	uci set system.vpn="vpn"
	uci set system.vpn.domain="weimarnetz.de"
	uci set system.vpn.prefix="v"
	uci set system.vpn.jsonpath="/freifunk/vpn/"
	uci set system.vpn.proto="olsr"
	uci set system.vpn.enable="on"
	uci set system.vpn.ipaddr="vpn.weimarnetz.de"

	uci commit system
}

_config_freifunk ()
{
	# set contact and user info only when data is fresh from meshkit, else leave all values
	[ -n "$FRESHMESHKIT" ] && {
		#contact section of freifunk
		uci set freifunk.contact="public"
		[ -n "$( uci -q get meshwizard.contact.name )" ] && {
			uci set freifunk.contact.name="$( uci -q get meshwizard.contact.name )"
		}
		[ -n "$( uci -q get meshwizard.contact.nickname )" ] && {
			uci set freifunk.contact.nickname="$( uci -q get meshwizard.contact.nickname )"
		}
		[ -n "$( uci -q get meshwizard.contact.mail )" ] && {
			uci set freifunk.contact.mail="$( uci -q get meshwizard.contact.mail )"
		}
		[ -n "$( uci -q get meshwizard.contact.phone )" ] && {
			uci set freifunk.contact.phone="$( uci -q get meshwizard.contact.phone )"
		}
		[ -n "$( uci -q get meshwizard.contact.note )" ] && {
			uci set freifunk.contact.note="$( uci -q get meshwizard.contact.note )"
		}
		#community section of freifunk
		uci set freifunk.community="public"
		[ -n "$( uci -q get meshwizard.community.name )" ] && {
			uci set freifunk.community.name="$( uci -q get meshwizard.community.name )"
		}
	}
	if [ "$INSTALLATION" = "ffweimar" ]; then
		uci set freifunk.community.owm_api="http://mapapi.weimarnetz.de"
		uci set freifunk.community.mapserver="http://map.weimarnetz.de"
	fi

	uci commit freifunk
 
}

_config_softwareinstall ()
{
	local service

	for service in olsrd crashlog_apport; do {
		/etc/init.d/$service enable
	} done

	for service in samba siproxd netserver; do {
		/etc/init.d/$service disable
	} done
}

_config_wireless()			# fixme! channels hardcoded
{
	local NODE="$1"
	local MAC htmode hwmode country ht_cap ht_cap_list hideht radiotype radiocard hidetx
	local temp="/tmp/config_wireless.tmp"
	local driver_path distance
	local network_append=
	local default_channel="$CHANNEL"
	local pointing2device

	# only for AP-interfaces:
	local default_encryption_type="${WIFI_ENCRYPTION:-none}"	# e.g. psk2
	local default_encryption_pass="$WIFI_PASS"			# e.g. mypass
	local hideE='#'
	[ "$default_encryption_type" = 'none' ] || hideE=

	# wireless.@wifi-iface[0].encryption=psk2 wireless.@wifi-iface[0].key=31122014

	[ -e "/etc/config/wireless" ] || {
		log "omitting section wireless, wifi n/a"
		return 0
	}

	[ -e "$temp" ] && rm -f "$temp"

	[ -z "$TXPOWER" ] && hidetx="#"

	for radiocard in 0 1 2 3; do {
		[ "$( uci get wireless.radio${radiocard}.disabled )" = "1" ] && {
			uci set wireless.radio${radiocard}.disabled=0
		}
	} done

for radiocard in 0 1 2 3; do {
	# old:
	# new:
	driver_path="$( uci get wireless.radio${radiocard}.path )"		# e.g. 'platform/ath9k' or 'platform/ar231x-wmac.0'
	distance="$(    uci get wireless.radio${radiocard}.distance )"

	# check if real wifi card or only VAP/hybrid interface
	local var="wireless.@wifi-iface[$radiocard].device"
	pointing2device="$( uci get $var )"	# e.g. radio1
	[ "$( uci get wireless.${pointing2device} )" = "wifi-device" ] || continue
	[ -n "$( uci get wireless.${pointing2device}.type )" ] || continue

	radiotype="$( uci get wireless.radio${radiocard}.type )"	# e.g. 'mac80211' or 'atheros'
	[ -z "$radiotype" ] && continue

	[ $radiocard -gt 0 ] && {
		echo
		echo '### next radio ###'
		echo
		network_append="RADIO${radiocard}"
	} >>"$temp"

	log "configuring radio${radiocard} ..."

	local hide_mac="#"
	MAC="$( uci get wireless.radio${radiocard}.macaddr )"
	if [ -z "$MAC" ]; then
		[ -z "$driver_path" ] && {
			hide_mac=
			MAC="11:22:33:44:55:66"
			log "[ERR] empty mac, we set $MAC"
		}
	else
		hide_mac=
	fi

	hwmode="$( uci get wireless.radio${radiocard}.hwmode )"		# backup current state
	hwmode="${hwmode:-11g}"
	[ "$HARDWARE" = 'UML' -a "$radiocard" = '0' ] && hwmode='11n'	# hwsim has 2 x dualcard

	case "$hwmode" in
		11g|11a)
			hideht="#"
		;;
	esac

	case "$( uci get wireless.radio${radiocard}.htmode )" in	# maybe switched off by user
		"")
			hideht="#"
		;;
	esac

	ht_cap_list="$( uci get wireless.radio${radiocard}.ht_capab )"	# backup current state

	ht_cap_uci_output()
	{
		for ht_cap in $ht_cap_list; do {
			echo "	list ht_capab	'$ht_cap'"
		} done
	}

	bssid_wellformed()
	{
		local channel="$1"			# e.g. 161
		local bssid="${2:-02:ca:ff:ee:ba:be}"

		case "$INSTALLATION" in
			liszt28|ffweimar)
				[ "$channel" = '5' ] && {
					log "[OK] enforcing special value '02:ca:ff:ee:ba:be' for $INSTALLATION"
					echo '02:ca:ff:ee:ba:be'
					return 0
				}
			;;
		esac

		bssid="$( echo "$bssid" | cut -b 1-11 )"	# 02:be:ef:ca:ff:ee -> 02:be:ef:ca

		if [ "$channel" -lt 100 ]; then
			if [ "$channel" -lt 10 ]; then
				echo "${bssid}:00:0${channel}"
			else
				echo "${bssid}:00:$channel"
			fi
		else
			# channel 161 -> bssid ends with ..:01:61"
			echo "${bssid}:0$( echo "$channel" | cut -b 1 ):$( echo "$channel" | cut -b 2-3 )"
		fi
	}

	# detect 5ghz-mode, those are working initially:
	#
	# channel  36 (5180mhz) HT40+| --  |NOHT
	# channel  40 (5200mhz) HT40+|HT40-| --
	# channel  44 (5220mhz) HT40+|HT40-|NOHT
	# channel  48 (5240mhz)  --  |HT40-|NOHT
	# channel 153 (5765mhz)  --  |HT40-|NOHT
	# channel 157 (5785mhz) HT40+|HT40-
	# channel 161 (5805mhz) HT40+|NOHT
	#
	# with jow's reghack:
	# 36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 149 153 157 161 165

	CHANNEL="$default_channel"

	get_wifi_band()
	{
		case "$hwmode" in
			11na|11a)
				echo 'a'
			;;
			*)
				echo 'g'
			;;
		esac
	}

	case "$( get_wifi_band )" in
		a)
			local channel_now="$( uci get wireless.radio${radiocard}.channel )"
			local var="wireless.@wifi-iface[$radiocard].bssid"
			local bssid_now="$( uci get $var )"

			if [ "$bssid_now" = "$( bssid_wellformed "$channel_now" "$BSSID" )" ]; then
				log "[OK] using already configured channel $channel_now"
				CHANNEL="$channel_now"
			else
				CHANNEL=36
			fi

			BSSID="$( bssid_wellformed "$CHANNEL" "$BSSID" )"

			log "[OK] using mode 801.$hwmode now and channel $CHANNEL with bssid: $BSSID"

			case "$MCAST_RATE" in
				1000|2000|5500)
					log "[OK] forcing mcast_rate to lowest basic-rate: 6000"
					MCAST_RATE="6000"
				;;
			esac
		;;
		*)
			BSSID="$( bssid_wellformed "$CHANNEL" "$BSSID" )"
		;;
	esac

	case "$CHANNEL" in
		36|37|38|39|40|149|153|161) htmode="HT40+" ;;
		44|157) htmode="HT40-" ;;
		1|2|3|4|5|6) htmode="HT40+" ;;
		   12|13|14) htmode="HT20" ;;		# fixme!
		          *) htmode="HT40-" ;;
	esac

	case "$PROFILE_MODE" in
		hybrid)
			htmode="HT20"
		;;
	esac

	case "$hwmode" in
		11g)
			htmode="HT20"
		;;
	esac

	local hide_noscan
	case "$htmode" in
		"HT20")
			hide_noscan="#"
		;;
	esac

	[ "$hideht" = "#" ] && hide_noscan="#"

	local chanbw="$( uci get wireless.radio${radiocard}.ath9k_chanbw )$( uci get wireless.radio${radiocard}.chanbw )"
	case "$chanbw" in
		5|10)
			hide_chanbw=
		;;
		*)
			chanbw=20
			hide_chanbw="#"
		;;
	esac

	country="DE"

	case "$PROFILE_MODE" in
		hybrid)
			local ssid_adhoc="ff.intern.$NODE.ch$CHANNEL"			# fixme! work with 'hidden'
			#local ssid_ap="$( uci get wireless.@wifi-iface[$(( radiocard + 1 ))].ssid )"
			#[ -z "$ssid_ap" ] || [ "$ssid_ap" = "LEDE" ] && 
			local ssid_ap="weimar.freifunk.net"

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
	option channel	$CHANNEL
$hide_chanbw	option chanbw	$chanbw		# since r32596
$hide_mac	option macaddr	$MAC
$hidetx	option txpower	$TXPOWER
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"


			cat >>"$temp" <<EOF
	option hwmode   $hwmode
${hideht}	option htmode   $htmode
$( ht_cap_uci_output )
EOF

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >>"$temp" <<EOF
config wifi-iface
	option device	radio${radiocard}
	option network	wlanadhoc${network_append}
	option mode	adhoc
	option bssid	'$BSSID'
	option ssid	'${ssid_adhoc}'
	option mcast_rate ${MCAST_RATE}
#	option bintval	1000
config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option encryption '$default_encryption_type'
	option mode	ap
$hideE	option encryption '$default_encryption_type'
$hideE	option key '$default_encryption_pass'
	option ssid	'${ssid_ap}'
EOF
		;;
		ap*)
			local var="wireless.@wifi-iface[$radiocard].ssid"
			local old_essid="$( uci get $var )"
			local new_essid="weimar.freifunk.net"

			[ -n "$SSID_ENFORCED" ] && {
				new_essid="$SSID_ENFORCED"
			}

			case "$old_essid" in
				*[0-9])
					new_essid="$old_essid"
				;;
				*")")
					new_essid="$old_essid"
				;;
				*" "*)
					new_essid="$old_essid"
				;;
				LaLaBa*|*Dach)
					new_essid="$old_essid"
				;;
			esac

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
$hidetx	option txpower	$TXPOWER
	option channel	$CHANNEL
$hide_mac	option macaddr	$MAC
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"

			cat >>"$temp" <<EOF
	option hwmode   $hwmode
${hideht}	option htmode   $htmode
$( ht_cap_uci_output )
EOF

			cat >>"$temp" <<EOF
config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option mode	ap
	option ssid	'${new_essid}'
$hideE	option encryption '$default_encryption_type'
$hideE	option key '$default_encryption_pass'
EOF
		;;
		*)
			local new_essid="ff.intern.$NODE.ch$CHANNEL"

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
	option channel	$CHANNEL
$hide_chanbw	option chanbw	$chanbw		# since r32596
$hide_mac	option macaddr	$MAC
$hidetx	option txpower	$TXPOWER
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"

			cat >>"$temp" <<EOF
	option hwmode	$hwmode
${hideht}	option htmode	$htmode
$( ht_cap_uci_output )
EOF

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >>"$temp" <<EOF
config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option mode	adhoc
	option bssid	'$BSSID'
	option ssid	'${new_essid}'
	option mcast_rate ${MCAST_RATE}
#	option bintval	1000
EOF
		;;
	esac

} done

	mv -f "$temp" /etc/config/wireless
}

_config_network ()
{
	local NODE="$1"
	local PROTO LANDEV WANDEV

	LANDEV="$( uci -q get network.lan.ifname )"
	WANDEV="$( uci -q get network.wan.ifname )"

	if [ "$GATEWAY" = "dhcp" ]; then
		PROTO="dhcp"

		[ -n "$LANDEV" -a -z "$WANDEV" ] && {
			log "swapping LANDEV with WANDEV, we are on singleport machine"
			WANDEV="$LANDEV"
			LANDEV=
		}
	else
		PROTO="static"
	fi

	# see 9d88ce9279c0e54ea53508d7636cdfdc8fc147be, delete really old network-sections for e.g. multiple wifi-ifs
	for section in $( uci show network | grep "=interface"$ | grep -v "6=interface"$ | grep -v "loopback=interface"$ | cut -d'=' -f1 ); do {
		uci delete $section
	} done
	_log it uci_commit daemon alert 'network: remove old sections'
	uci commit network

	[ -n "$LANDEV" ] && {
		cat >>/etc/config/network <<EOF

config 'interface' 'lan'
	option 'ifname'   '$LANDEV'
$( test -n "$LANMAC" && echo "	option 'macaddr' '$LANMAC'" )
	option 'proto'    'static'
	option 'ipaddr'   '$( _ipsystem get $NODE | grep LANADR= | cut -d'=' -f2 )'
	option 'netmask'  '$( _ipsystem get $NODE | grep LANMSK= | cut -d'=' -f2 )'

EOF
	}

	if [ -z "$WANDEV" ]; then
			:		# no wandev/singleport
	else
		local hide_gateway="#"
		local wan_ipaddr="$(  _ipsystem get $NODE | grep WANADR= | cut -d'=' -f2 )"
		local wan_netmask="$( _ipsystem get $NODE | grep WANMSK= | cut -d'=' -f2 )"
		local wan_gateway=
		local username password hideip wan_dns


if [ "$INSTALLATION" = "ffweimar" ]; then
        PROTO="dhcp" #set dhcp as default for wan
        hideip="true"
        hide_gateway="#"
fi

		cat >>/etc/config/network <<EOF

config 'interface' 'wan'
	option 'ifname' '$WANDEV'
$( test -n "$WANMAC" && echo "	option 'macaddr' '$WANMAC'" )
$( test -n "$wan_dns" && echo "	option 'wan_dns' '$wan_dns'" )
	option 'proto' '$PROTO'
	option 'dyndns' '$dyndns'
${hideip:+#}	option 'ipaddr'	 '$wan_ipaddr'
${hideip:+#}	option 'netmask' '$wan_netmask'
$hide_gateway	option 'gateway' '$wan_gateway'
${username:+	option 'username' '$username'}
${password:+	option 'password' '$password'}
${password:+	option 'authfail' '1'	# since r33291}
EOF



	fi
	local radiocard
	local network_append
	local profile_mode_tmp=$PROFILE_MODE

	ipv4address_plus_x()
	{
		local ip="$1"
		local x="$2"

		local oldIFS="$IFS"; IFS='.'; set -- $ip; IFS="$oldIFS"
		echo "$1.$2.$3.$(( $4 + $x ))"
	}

for radiocard in 0 1 2 3; do {

	[ $radiocard -gt 0 ] && {
		network_append="RADIO${radiocard}"
                PROFILE_MODE="adhoc"                                            # only first wifi card will provide an ap          
	}

	grep "option network" "/etc/config/wireless" | grep -q "wlan${network_append}" || continue

	local wlan_ipaddr wlan_netmsk wlan_ifname hide_wifi
	local alias_ifname alias_proto alias_ipaddr alias_netmask alias_network
	local hide="#"
	
	local pointing2type="$( uci -q get wireless.@wifi-iface[${radiocard}].type )"
	
	case "$pointing2type" in
		mac80211)
			wlan_ifname="wlan0"
		;;
		atheros)
			wlan_ifname="ath0"
		;;
		*)
			wlan_ifname="wlan0"
		;;
	esac

	wlan_ipaddr="$( _ipsystem get $NODE | grep WIFIADR= | cut -d'=' -f2 )"

	### radiocard-0
	# adhoc = .1	adhoc or ap = .1
	# ap    = .2
	### radiocard-1
	# adhoc = .3	adhoc or ap = .3
	# ap    = .4
	### radiocard-2
	# adhoc = .5	adhoc or ap = .5
	# ap    = .6

	if grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}"; then
		local ip_1stIF_addvalue=$(( (($radiocard + 1) * 2 )     - 1 ))
		local ip_2ndIF_addvalue=$(( (($radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem get $NODE | grep ^"WIFI_DHCP_PRE=" | cut -d'=' -f2 )"
	else
		local ip_1stIF_addvalue=$(( (($radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem get $NODE | grep ^"WIFI_PRE=" | cut -d'=' -f2 )"
	fi

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlan${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_1stIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF

	grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}" || continue

	wlan_netmsk="$( _ipsystem get $NODE | grep ^"WIFI_PRE=" | cut -d'=' -f2 )"

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlanadhoc${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_2ndIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF


} done

	[ -n "$alias_ipaddr" ] && hide=

	cat >>/etc/config/network <<EOF
${hide}config 'alias'
$hide	option 'interface' '${alias_network:-wlan}'
$hide	option 'proto' 'static'
$hide	option 'ipaddr' '$alias_ipaddr'
$hide	option 'netmask' '${alias_netmask:-255.255.255.255}'
$( test -n "$alias_gateway" && echo "	option 'gateway' '$alias_gateway'" )
EOF

PROFILE_MODE=$profile_mode_tmp                                  #reset original profile mode

  cat >>/etc/config/network <<EOF
config interface 'tap0'
  option ifname 'tap0'
EOF

}

_config_dhcp ()			# domain = .olsr
{
	local NODE="$1"
	local wan_dns="$( uci -q get network.wan.dns )"
	local cache domain

	if [ "$INSTALLATION" = "ffweimar" ]; then       #set domain to olsr for profile ffweimar
		domain="olsr" 
	else
		domain="lan"
	fi
	
	case $HARDWARE in
		"TP-LINK TL-WR1043ND"|"BulletM")
			cache="1000"
		;;
		*)
			cache="100"
		;;
	esac

	[ -n "$wan_dns" ] && DNSSERVER="$wan_dns"

	uci -q delete dhcp.@dnsmasq[0]
	uci -q add dhcp dnsmasq
	uci -q set dhcp.@dnsmasq[0].cachesize="$cache"	# query with 'kill -SIGUSR1 \$( pidof dnsmasq ); logread | tail -n5'
	uci -q set dhcp.@dnsmasq[0].domainneeded="0"	# forward querys without dots
	uci -q set dhcp.@dnsmasq[0].boguspriv="1"
	uci -q set dhcp.@dnsmasq[0].filterwin2k="0"	# enable for dial on demand
	uci -q set dhcp.@dnsmasq[0].localise_queries="1"
	uci -q set dhcp.@dnsmasq[0].rebind_protection="0"	# disable if upstream must serve RFC1918 addresses
	uci -q set dhcp.@dnsmasq[0].rebind_localhost="0"	# enable for RBL checking and similar services
	## list rebind_domain example.lan # whitelist RFC1918 responses for domains
	uci -q set dhcp.@dnsmasq[0].local="/$domain/"
	uci -q set dhcp.@dnsmasq[0].domain="$domain"
	uci -q set dhcp.@dnsmasq[0].expandhosts="1"
	uci -q set dhcp.@dnsmasq[0].nonegcache="0"
	uci -q set dhcp.@dnsmasq[0].authoritative="1"
	uci -q set dhcp.@dnsmasq[0].readethers="1"
	uci -q set dhcp.@dnsmasq[0].leasefile="/tmp/dhcp.leases"
	uci -q set dhcp.@dnsmasq[0].resolvfile="/tmp/resolv.conf.auto"
	uci -q add_list dhcp.@dnsmasq[0].addnhosts="/var/etc/hosts"
	uci -q add_list dhcp.@dnsmasq[0].addnhosts="/etc/local.hosts"
	uci -q add_list dhcp.@dnsmasq[0].server="$DNSSERVER"
	# list server		'/mycompany.local/1.2.3.4'
	# option nonwildcard	1
	# list interface	br-lan
	uci -q add_list dhcp.@dnsmasq[0].notinterface="wan"
	uci -q set dhcp.@dnsmasq[0].dhcpscript="/etc/dhcp-script.d/10dhcpscript"
	
	uci -q delete dhcp.lan
	uci -q set dhcp.lan="dhcp"
	
	uci -q set dhcp.lan.interface="lan"
	uci -q set dhcp.lan.start=$( _ipsystem get "$NODE" | grep ^"LANDHCPSTART=" | cut -d'=' -f2 )
	uci -q set dhcp.lan.limit=$( _ipsystem get "$NODE" | grep ^"LANDHCPNUM="   | cut -d'=' -f2 )
	uci -q set dhcp.lan.leasetime="2h"
	uci -q set dhcp.lan.force="1"
	uci -q set dhcp.lan.ignore=${DHCP_IGNORE_LAN:-0}
	
	uci -q delete dhcp.wlan
	uci -q set dhcp.wlan="dhcp"
	uci -q set dhcp.wlan.interface="wlan"
	uci -q set dhcp.wlan.start=$( _ipsystem get "$NODE" | grep ^"WIFIDHCPSTART=" | cut -d'=' -f2 | cut -d'.' -f4 )
	uci -q set dhcp.wlan.netmask=$( _net cidr2mask "$( _ipsystem get "$NODE" | grep ^"WIFI_DHCP_PRE=" | cut -d'=' -f2 )" ) # 255.255.255.240?
	uci -q set dhcp.wlan.limit=$( _ipsystem get "$NODE" | grep ^"WIFIDHCPNUM=" | cut -d'=' -f2 )			 # fixme! better: 21
	uci -q set dhcp.wlan.leasetime="1h"
	uci -q set dhcp.wlan.force="1"
	uci -q set dhcp.wlan.ignore=${DHCP_IGNORE_WLAN:-0}

# FIXME!
# disable since we have a proper fix:
# the gateway must be valid: in normal wifi mode = WIFIADR and in hybrid-mode = WIFIADR + 1
#	uci -q add_list dhcp.wlan.dhcp_option="121,10.63.0.0/16,$( _ipsystem ffweimar $NODE | grep LANADR= | cut -d'=' -f2 )"

	uci -q delete dhcp.wan
	uci -q set dhcp.wan="dhcp"
	uci -q set dhcp.wan.interface="wan"
	uci -q set dhcp.wan.ignore="1"
	
	uci commit dhcp
}

_config_olsrd ()	# example here: http://olsr.org/git/?p=olsrd.git;a=blob;f=files/olsrd.conf.default.full
{

	local NODE="$1"
	local speed="${OLSR_SPEED:-6}"
	local hide_nameservice slave
	local showspeed=
	local hidevals=

	# speed makro there since 2013-apr
	grep -q "sven-ola" "/etc/init.d/olsrd" && {
		hidev="#"
		showspeed="	option speed 		'$speed'"
	}

	if [ -z "$GATEWAY" -a "$PROFILE_MODE" = "ap" ]; then
		slave=1
	else
		slave=0
	fi

	[ $speed -gt 10 ] && hide_nameservice="#"

	local INTERFACES1		# Mode: ether
	local INTERFACES2		# Mode: adhoc
	local INTERFACES3   # tap interface for vpn
	local hna_net hna_mask main_ip

	hna_net="$(  _ipsystem get $NODE | grep OLSR_HNA= | cut -d'=' -f2 | cut -d'/' -f1 )"
	hna_mask="$( _ipsystem get $NODE | grep OLSR_HNA= | cut -d'/' -f2 )"
	hna_mask="$( _net cidr2mask $hna_mask )"
	tap_broadcast="$( _ipsystem get $NODE | grep WIFIVPNSERVERADR= | cut -d'=' -f2 )"

	local landev="lan"
	local wandev="wan"
	local tapdev="tap0"

	output_useable_wifi_networks()
	{
		local wifidev="wlan"
		local radiocard network_append spacer

		for radiocard in 0 1 2 3; do {
			[ $radiocard -gt 0 ] && network_append="RADIO${radiocard}"
			if   grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}"; then
				echo -n "${spacer}wlanadhoc${network_append}"
				spacer=" "
			elif grep "option network" "/etc/config/wireless" | grep -q "wlan${network_append}"; then
				echo -n "${spacer}wlan${network_append}"
				spacer=" "
			fi
		} done
	}

	[ -z "$( uci -q get network.wan.ifname )" ] && {
		wandev=
	}

	[ "$( uci -q get network.wan.proto )" = "static" ] || {
		case "$NETWORK" in
			satama*|ejbw*)
			;;
			*)
				# only olsr on wan, if no pppoe/dhcp
				# hint: we must be sure, that network-section is already written
				wandev=
			;;
		esac

	}

	[ -n "$wandev" ] && {
		wandev=" $wandev"
	}

	case "$PROFILE_MODE" in 
		ap*)
			INTERFACES1="${landev}${wandev}"
			INTERFACES2="${tapdev}"
      INTERFACES3=
		;;
		adhoc*|hybrid)
			INTERFACES1="${landev}${wandev}"
			INTERFACES2="$( output_useable_wifi_networks )"
      INTERFACES3="${tapdev}"
		;;
	esac

	main_ip="$( uci -q get network.lan.ipaddr )"
	[ -z "$main_ip" ] && {
		main_ip="$( uci -q get network.wan.ipaddr )"
	}

	local fisheye hello_interval tc_interval

	fisheye="1"
	hello_interval="$(( $speed / 2 + 1 ))"

	if [ "$fisheye" = "1" ]; then
		tc_interval="$(( $speed / 2 ))"
		[ "$tc_interval" = "0" ] && tc_interval="1"
	else
		tc_interval="$(( $speed * 2 ))"
	fi

	cat >/etc/config/olsrd <<EOF
config olsrd
	option MainIp			'${main_ip:-0.0.0.0}'
	option DebugLevel		'0'		# 0...9
	option ClearScreen		'no'		# start with -dispout
	option AllowNoInt		'yes'
	option IpVersion		'4'
	option FIBMetric		'flat'		# approx, correct, flat
	option Willingness		'7'
	option TcRedundancy		'2'
	option LinkQualityFishEye	'$fisheye'
	option LinkQualityAlgorithm	'$OLSR_METRIC'	# etx_ff, etx_ffeth, etx_float, etx_fpm
	option MprCoverage		'7'
#	option RtTable			'111'
#	option RtTableDefault		'254'		# cat /etc/iproute2/rt_tables

config meta
	option speedvalue		'$speed'
	option speedalgo		'1'		# like sven-ola fff 1.7.4
	option hnaslave			'$slave'

config Interface
	list interface			'$INTERFACES1'
	option Ip4Broadcast		'255.255.255.255'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'		# vals for speed $speed
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF
[ "$OLSR_METRIC" = "etx_ffeth" ] && {
	cat >>/etc/config/olsrd <<EOF
	option Mode			'ether'		# enforces cost of 0.100
EOF
}
	[ -n "$INTERFACES2" ] && { 
  BROADCASTADR='255.255.255.255'
  [ "$INTERFACES2" = "$tapdev" ] && BROADCASTADR="$tap_broadcast"
  cat >>/etc/config/olsrd <<EOF

config Interface
	list interface			'$INTERFACES2'
	option Ip4Broadcast		'$BROADCASTADR'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF

}

[ -n "$INTERFACES3" ] && {

  BROADCASTADR='255.255.255.255'
  [ "$INTERFACES3" = "$tapdev" ] && BROADCASTADR="$tap_broadcast"
  cat >>/etc/config/olsrd <<EOF

config Interface
	list interface			'$INTERFACES3'
	option Ip4Broadcast		'$BROADCASTADR'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF

}
	local interface_mode="mesh"
#	case "$PROFILE_MODE" in
#		adhoc*)
#			case "$( uci -q get wireless.radio0.hwmode )" in
#				*"a"*)
#					interface_mode="ether"		# fixme! not a good idea for multipoint-stations
#				;;
#			esac
#		;;
#	esac

[ "$OLSR_METRIC" = "etx_ffeth" -a -n "$INTERFACES2" ] && {
	cat >>/etc/config/olsrd <<EOF
	option Mode			'$interface_mode'		# uses normal cost-calculation / default
EOF
}

	cat >>/etc/config/olsrd <<EOF

config LoadPlugin
	option library  'olsrd_jsoninfo.so.0.0'
	option accept	'0.0.0.0'
	option port	'9090'

config LoadPlugin
	option library	'olsrd_arprefresh.so.0.1'

config 'LoadPlugin'
	option 'library' 'olsrd_nameservice.so.0.3'
	option 'ignore' '0'
	option 'hosts_file' '/var/etc/hosts'
	option 'suffix' '.olsr'
	option 'interval' '180'
	option 'timeout' '3600'
	option 'latlon_file' '/var/run/latlon.js'
	option 'latlon_infile' '/var/run/latlon.txt'


config LoadPlugin
	option library	'olsrd_dyn_gw.so.0.5'
	option 'CheckInterval' '5000'
	option 'PingInterval' '40'
	option 'Ping' '209.244.0.3'
	option 'Ping' '8.8.8.8'

config LoadPlugin
	option library	'olsrd_txtinfo.so.0.1'
	option accept	'0.0.0.0'
	option port	'2006'

#config LoadPlugin
#	option library	'olsrd_dyn_gw.so.0.5'
#	option 'CheckInterval' '6000'		# milliseconds
#	option 'PingInterval' '40'		# seconds
#	option 'Ping' '8.8.8.8'
#	option 'Ping' '141.1.1.1'

config 'Hna4'
        option 'netaddr' '$hna_net'
        option 'netmask' '$hna_mask'
EOF

#	[ -n "$GATEWAY" ] && {
#		cat >>/etc/config/olsrd <<EOF
#
#config 'Hna4'
#        option 'netaddr' '0.0.0.0'
#        option 'netmask' '0.0.0.0'
#
#EOF
#	}

#EOF
}

_config_roaming()
{
	. /tmp/loader
	local wired_networks="$1"		# e.g. 'lan' or 'lan wan'
	local special_ssid="$2"
	local index network list list_ap has_5ghz has_2ghz is_hybrid milliwatt disassoc_low_ack

#	local ssid2	# TODO: dhcp complains about missing IP on dev
#	ssid2="freifunk ($HOSTNAME"
#	ssid2="$( _sanitizer run "$ssid2" length:30 )"
#	ssid2="$ssid2)"
#	uci add wireless wifi-iface
#	uci set wireless.@wifi-iface[-1].network='wlan'
#	uci set wireless.@wifi-iface[-1].device='radio1'
#	uci set wireless.@wifi-iface[-1].mode='ap'
#	uci set wireless.@wifi-iface[-1].ssid="$ssid2"
#	uci set wireless.@wifi-iface[-1].ssid_donttouch='true'

	list_ap="$( _wifi get any mode ap ) $wired_networks"
	[ -z "$list_ap" ] && return 1

	# e.g. dnsmasq 2.66 or openwrt script are broken for DHCP-range
	[ -e "/lib/modules/$( uname -r )/macvlan.ko" ] || return 1
	modprobe 'macvlan'

	_uci remove_section 'network.@alias[].interface' 'mastergate'
	uci set network.mastergate='interface'			# here we collect all interfaces, see below
	uci set network.mastergate.type='bridge'		# bridge needed for multiple interfaces
	uci set network.mastergate.proto='static'		# list of ifnames is added below
	uci set network.mastergate.ipaddr="$ROAMING_GATEWAY" # global from /etc/kalua/net
	uci set network.mastergate.netmask="$( _net cidr2mask "$ROAMING_PRE" )" 

	# we occupy the existing 'wlan'-section (generated from apply_profile)
	uci set dhcp.wlan.interface='mastergate'

	# maybe also fill: 1, 3, 6, 12, 28 = ???
	uci del      dhcp.wlan.dhcp_option
	uci add_list dhcp.wlan.dhcp_option="3,$ROAMING_GATEWAY"	# same like 'option:router' is "option name => RFC 2132"
	uci add_list dhcp.wlan.dhcp_option="6,$ROAMING_DNS"

	uci set dhcp.wlan.leasetime='12h'	# very long: otherwise a ssh-session is lost when the IP changes...
	uci set dhcp.wlan.start="$ROAMING_DHCPSTART_LOCAL"
	uci set dhcp.wlan.limit='253'
	uci -q delete dhcp.wlan.netmask		# otherwise 'wlan.start' has no effect

	# FIXME! 2nd AP on same band does not work
	for index in $list_ap; do {
		if network="$( uci -q get "wireless.@wifi-iface[$index].network" )"; then
			# e.g. 'wlanRADIO1' 'wlan'

			case "$HARDWARE" in
				*)
					# force active
					uci set "wireless.@wifi-iface[$index].disabled=0"
				;;
			esac

			if _wifi is2ghz "$index"; then
				has_2ghz='true'
				# https://wiki.openwrt.org/doc/uci/wireless#inactivity_timeout_options
				if [ -n "$special_ssid" ]; then
					disassoc_low_ack=0
				else
					disassoc_low_ack=1
				fi

				uci set "wireless.@wifi-iface[$index].disassoc_low_ack=$disassoc_low_ack"
				uci del "wireless.@wifi-iface[$index].max_inactivity"
#				uci set "wireless.@wifi-iface[$index].max_inactivity"='30'
			else
				has_5ghz='true'
				uci set "wireless.@wifi-iface[$index].disassoc_low_ack=0"	# sticky 5ghz
			fi
		else
			# e.g. 'lan'
			network="$index"
			uci delete dhcp.$index
		fi

		# omit dnsmasq-logerrors: in roaming mode we should
		# only answer on 'mastergate' not e.g. 'wlan' (or even 'lan')
		case " $( uci -q get dhcp.@dnsmasq[0].notinterface ) " in
			*" $network "*)
				# only add once
			;;
			*)
				uci add_list dhcp.@dnsmasq[0].notinterface="$network"
			;;
		esac

		uci set network.roaming${index}='device'
		uci set network.roaming${index}.type='macvlan'
		uci set network.roaming${index}.name="roaming${index}"
		uci set network.roaming${index}.ifname="@$network"
		uci set network.roaming${index}.macaddr='02:ff:ff:ff:00:00'		# same on all bands

		list="$( uci -q get network.mastergate.ifname )"
		case "$list" in
			*"roaming${index}"*)
			;;
			*)
				uci set network.mastergate.ifname="${list}${list:+ }roaming${index}"
			;;
		esac
	} done

	_uci already_added 'olsrd' 'Hna4' 'netaddr' "$ROAMING_NET_LOCAL" || {
		uci add olsrd Hna4 >/dev/null
		uci set olsrd.@Hna4[-1].netaddr="$ROAMING_NET_LOCAL"
		uci set olsrd.@Hna4[-1].netmask="$( _net cidr2mask "$ROAMING_PRE_LOCAL" )"
	}

	_uci config_add_alias 'mastergate' "$ROAMING_ADR_LOCAL/$ROAMING_PRE_LOCAL"

	# TODO: hostapd: band-steering
	# https://forum.openwrt.org/viewtopic.php?id=33335
	#
	#if _wifi longshot_name >/dev/null; then
	#	_wifi set ap anyfreq 'off'
	#else
	#	# TODO: test if this speeds up roaming? CoverageClass1 = 450m
	#	_wifi set ap 2ghz distance '100'
	#	_wifi set ap 2ghz beacon_int '250'	# better powersafe and not too slow
	#	_wifi set ap 2ghz txpower '10'
	#
	#	_wifi set ap 5ghz distance '100'
	#	_wifi set ap 5ghz beacon_int  '50'	# maybe this helps better sticking to 5ghz
	#	_wifi set ap 5ghz txpower '20'
	#
	#	_wifi set ap anyfreq mcast_rate ''	# use defaults
	#
	#	# TODO: be band-specific
	#	[ -n "$( _wifi get any mode adhoc )" ] && is_hybrid='true'	# FIXME! mesh?
	#
	#	# single band 5ghz AP
	#	[ -n "$has_5ghz" -a -z "$has_2ghz" ] && {
	#		[ -n "$is_hybrid" ] && {
	#			_wifi set ap 5ghz beacon_int '50'
	#			_wifi set ap 5ghz txpower '20'
	#		}
	#	}
	#
	#	# TODO: uci var for describing "next to me/wired is already an adhoc-only device, so do not power up my adhoc"
	#	# single band 2ghz AP
	#	[ -z "$has_5ghz" -a -n "$has_2ghz" ] && {
	#		[ -n "$is_hybrid" ] && {
	#			_wifi set ap 2ghz beacon_int '125'
	#			_wifi set ap 2ghz txpower '20'
	#		}
	#	}

		# this should make the roaming-better, because the client does not 'glue' that much at an AP
		# TODO: do not if nexthop is wired
	#	[ -n "$has_2ghz" ] && {
	#		bool_true 'system.@monitoring[0].txpower_auto' && {
	#			milliwatt=-1	# means: go lower and lower by 1 milliwatt
	#			echo >>$SCHEDULER "_wifi reduce_txpower_if_compatible_roaming_nodes_are_near 2ghz $milliwatt"
	#		}
	#	}
	#fi

	return 0
}

[ -e "/etc/kalua_init" ] && {
	PARTITION="$( mount | sed -n 's/\(^.*mtd.*\) on .*/\1/p' )"       
        flash_free=$(df | sed -n "s#^${PARTITION:-/dev/root}[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*#\1#p")
	total_ram=$( grep MemTotal /proc/meminfo | cut -f2 -d ':'| cut -f1 -d 'k'| tr -d ' ')

	if [ $total_ram -lt 16384 ] && [ $flash_free -gt 340 ]; then
		log "[OK] building kalua-loader on flash, we are low on RAM =< 16mb"
        	mkdir "/etc/kalua.w"
                /etc/kalua_init
                . /tmp/loader
                [ "$PROFILE_MODE" = "adhoc" ] && {
			log "[OK] marking this node for mode SIMPLE_MESHNODE"
			touch "/www/SIMPLE_MESHNODE"
		}
	
	else
		log "[OK] building kalua-loader in ramdisk"
		/etc/kalua_init
		. /tmp/loader
	fi


	/etc/init.d/S41build_static_netparam start # it's essential for ipsystem()
}

# enforce settings delivered by meshkit
# we assume, if someone creates a package with meshkit, there'll be also settings made
# the file shouldn't exist in sysupgrade packages from our homepage
[ -e /rom/etc/config/meshwizard ] && {
	cp "/rom/etc/config/meshwizard" "/etc/config/meshwizard"
  FRESHMESHKIT="YO"
}

# copy opkg.conf from build system
[ -e /rom/etc/opkg.conf ] && {
	cp "/rom/etc/opkg.conf" "/etc/opkg.conf"
}

# copy profile as it will be kept by sysupgrade 
[ -e /rom/etc/profile ] && {
	cp "/rom/etc/profile" "/etc/profile"
}

# rewrite new settings
for SECTION in softwareinstall wireless network system freifunk olsrd dhcp cron roaming; do {
	log "....working on section '$SECTION'"
	_config_$SECTION "$NODENUMBER"
	log "[ok] ready with section '$SECTION'"
} done

/etc/init.d/count_reboots enable
/etc/init.d/generate_kalua_loader enable
/etc/init.d/end_boot enable
/etc/init.d/cron enable
/etc/init.d/set_etc_hardware enable
/etc/init.d/S70prepare_fff+ enable
/etc/init.d/S43ethers_fff+ enable
/etc/init.d/S41build_static_netparam enable
# disable zram until https://github.com/weimarnetz/weimarnetz/issues/251 is solved
/etc/init.d/zram disable
/etc/init.d/S99vpn enable
/etc/init.d/netfilter enable
/etc/init.d/crashlog_apport enable
/etc/init.d/S90olsr-prio disable


[ -e "/etc/init.d/olsrd6" ] && {
    log "disabling olsrd6"
    /etc/init.d/olsrd6 stop
    /etc/init.d/olsrd6 disable
}

[ -e "/etc/init.d/firewall" ] && {
	/etc/init.d/firewall disable
	}

[ -e "/etc/init.d/freifunk" ] && {
	/etc/init.d/freifunk disable
	}

#[ -e "/etc/init.d/S90olsr-prio" -a -x "/usr/sbin/tc" ] && {
#  /etc/init.d/S90olsr-prio enable
#}

# webserver-related stuff
uci set uhttpd.main.index_page="weimar-splash-index.sh"
uci set uhttpd.main.error_page="/weimar-splash-index.sh"
uci set uhttpd.main.config="/etc/httpd.conf"
uci set uhttpd.main.interpreter=".sh=/bin/ash"
# set bootstrap as new default theme
#uci set luci.main.mediaurlbase="/luci-static/bootstrap"

uci set uhttpd.main.max_requests="5"
# uci set uhttpd.main.script_timeout=5			// fixme! needs testing
# uci set uhttpd.main.network_timeout=5
uci delete uhttpd.main.listen_https
uci commit 


#copy alternative status.html if no luci is installed

if [ -d /www/cgi-bin/luci ]; then
	rm /www/cgi-bin-status.html.weimarnetz
else
	mv /www/cgi-bin-status.html.weimarnetz /www/cgi-bin-status.html
fi


touch /www/SOFTWARE_FULLY_INSTALLED

. /tmp/loader

has_default_route && {
		_ssh sanitize_and_cleanup_keys
		[ -e /tmp/REGISTRATED ] && rm /tmp/REGISTRATED
		/usr/sbin/cron.registrator_client.sh
	}


echo
echo "[ok] R E A D Y"
echo
echo "removing /etc/init.d/apply_profile with:"
echo "rm /etc/init.d/apply_profile"
echo
echo "maybe kill S98apply_profile!"
echo "now type: reboot && exit"
[ -n "$FAILSAFE" ] && echo "you are in FAILSAFE mode, try 'reboot -f && exit'"
exit 0
# END

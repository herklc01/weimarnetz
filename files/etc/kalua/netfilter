#!/bin/sh

# marks:
# 0x11 = port80, redirect to local port 80
# 0x12 = port443, redirect to local port 443
# 0x13 = port53udp, redirect to local port 53
# 0x14 = port53tcp, redirect to local port 53
# 0x15 = port53udp, redirect to local port 5353
# 0x16 = port53tcp, redirect to local port 5353
# 0x22 = adblocking, gets rejected
# 0x33 = connection_start
# 0x44 = connection_close
# 0x88 = unauthenticated, gets rejected

_netfilter_start()
{
	mkdir -p '/tmp/NETFILTER'

	_netfilter ipforwarding_needed && {
		_netfilter ipforwarding_start
	}

	_netfilter masquerade_start
	_netfilter conntrack_adjust_max		# needs testcase + respect /database-ramdisk
	_netfilter mssfix

	[ -e "/etc/init.d/apply_profile" ] && return 0
}

_netfilter_stop()
{
	local option="$1"	# string: remember_over_reboot = ror
	local funcname='netfilter_stop'
	local list_user="$( _netfilter user_list )"
	local ip mediatype dev hash mac

	[ -d '/tmp/NETFILTER' ] || return 0
	mkdir "/tmp/NETFILTER/isrunning_$funcname" || return 0

	[ -n "$list_user" ] && {
		for mac in $list_user; do {
			ip="$( _net mac2ip "$mac" )"
			dev="$( _net mac2dev "$mac" )"

			if _net dev_is_wifi "$dev"; then
				_net both_ipv4_in_same_subnet "$ip/32" "$ROAMING_NET/$ROAMING_PRE" && {
					_log it $funcname daemon debug "ignore roaming ip '$ip'"
					continue
				}
			_netfilter user_del "$mac" "$funcname"
			fi
		} done >"/tmp/NETFILTER_AUTOADD"
	}

	case "$option" in
		'remember_over_reboot'|'ror')
			# avoid writing an empty file
			if grep -sq '# non_wifi' '/tmp/NETFILTER_AUTOADD' ; then
				bool_true 'system.@weblogin[0].always_reachable' || {
					grep '# non_wifi' '/tmp/NETFILTER_AUTOADD' >'/www/NETFILTER_AUTOADD'
				}
			else

				rm '/www/NETFILTER_AUTOADD'
			fi
		;;
	esac

	_netfilter stop_all_tables
	rm -fR "/tmp/NETFILTER" "/tmp/NETFILTER/isrunning_$funcname"
	_netfilter ipforwarding_revert
}


_netfilter_convert_speed_to_bit()
{
	local speed="$1"	# 32kbit | 1mbit | 128000

	case "$speed" in
		*'kbit')
			echo $(( $( echo "$speed" | cut -d'k' -f1 ) * 1024 ))
		;;
		*'mbit')
			echo $(( $( echo "$speed" | cut -d'm' -f1 ) * 1024 * 1024 ))
		;;
		*)
			echo "$speed"
		;;
	esac
}

_netfilter_stats()
{
	local context="$1"
	local unit="$2"
	local line bytes packets

	case "$context" in
		forward_lan2lan)
			line="$( $IPT -nxvL FORWARD | grep -F "!$WIFIDEV !$WIFIDEV" )"
		;;
		forward_lan2wifi)
			line="$( $IPT -nxvL FORWARD | grep -F "!$WIFIDEV $WIFIDEV" )"
		;;
		forward_wifi2wifi)
			line="$( $IPT -nxvL FORWARD | grep -F "$WIFIDEV  $WIFIDEV" )"
		;;
		*)
			if _sanitizer run "$context" mac check; then
				line="$( $IPT -t mangle -nxvL FORWARD | grep -F "incoming_$context" )"

				explode $line
				packets="${1:-0}"
				bytes="${2:-0}"

				line="$( $IPT -t mangle -nxvL FORWARD | grep -F "outgoing_$context" )"
			else
				return 1
			fi
		;;
	esac

	explode $line
	packets=$(( ${packets:-0} + ${1:-0} ))
	bytes=$(( ${bytes:-0} + ${2:-0} ))

	case "$unit" in
		packets)
			echo "$packets"
		;;
		bytes)
			echo "$bytes"
		;;
		kilobytes)
			echo $(( bytes / 1000 ))
		;;
		megabytes)
			echo $(( bytes / 1000000 ))
		;;
	esac
}

_netfilter_conntrack_adjust_max()	# see: http://wiki.khnet.info/index.php/Conntrack_tuning
{
	local funcname="netfilter_conntrack_adjust_max"
	local max="$1"
	local file_conntrack="/proc/sys/net/nf_conntrack_max"
	local file_buckets="/sys/module/nf_conntrack/parameters/hashsize"
	local buckets old_buckets old_max

	# do not conntrack DNS/olsrd - formally: '-j NOTRACK' - see: https://dev.openwrt.org/ticket/19929
#	$IPT -t raw -I PREROUTING -p udp --dport 53 -j CT --notrack	# with this rule contacting external DNS over >1 hop does not work
	$IPT -t raw -I OUTPUT     -p udp --dport 53 -j CT --notrack
	$IPT -t raw -I PREROUTING -p udp --dport 698 -d 255.255.255.255 -j CT --notrack
	$IPT -t raw -I OUTPUT     -p udp --dport 698 -d 255.255.255.255 -j CT --notrack

	# TODO: test how high can we go with 32mb
	[ $( _system ram_size ) -lt 32768 ] && return 0

	[ -e "$file_conntrack" ] || return 0
	read -r old_max <"$file_conntrack"

	[ -z "$max" ] && {
		max="$( _system ram_size )"		# kilobytes
		if [ $max -lt 16384 ]; then
			max=1024
		else
			max=$(( (max * 3) / 2 ))	# x1.5
		fi
	}

	grep -q ^"net.netfilter.nf_conntrack_max=${max}"$ "/etc/sysctl.conf" || {
		echo "net.netfilter.nf_conntrack_max=${max}" >>"/etc/sysctl.conf"
	}

	read -r old_buckets <'/proc/sys/net/netfilter/nf_conntrack_buckets'
	buckets=$(( max / 8 ))
	[ $buckets -gt 1816 ] && buckets=1816		# klog/moduleinfo says this is max

	_log it $funcname daemon info "set $old_max -> $max conntrack-entries / $old_buckets -> $buckets buckets, needs $(( (max * 350) / 1024 )) kilobytes (each 350 bytes)"	# divisor_valid
	echo "$max" >"$file_conntrack"		# check usage via: wc -l /proc/net/nf_conntrack
	echo "$buckets" >"$file_buckets"
}

_netfilter_ipforwarding_needed()
{
	[ -x "/usr/sbin/olsrd" ] || return 1
	[ "$( uci -q get olsrd.@olsrd[0].disabled )" = "1" ] && return 1

	return 0
}

_netfilter_ipforwarding_start()
{
	local funcname="netfilter_ipforwarding_start"
	local kernel="/proc/sys/net/ipv4/ip_forward"
	local state

	mkdir -p '/tmp/NETFILTER'

	read -r state <"$kernel"
	echo "$state" >'/tmp/NETFILTER/FORWARDING_STATE_OLD'

	_log it $funcname daemon info "writing 1 to $kernel"
	echo 1 >'/proc/sys/net/ipv4/ip_forward'
}

_netfilter_ipforwarding_revert()
{
	local funcname='netfilter_ipforwarding_revert'
	local file='/tmp/NETFILTER/FORWARDING_STATE_OLD'
	local kernel='/proc/sys/net/ipv4/ip_forward'
	local state

	[ -e "$file" ] && {
		read -r state <"$file"

		pidof olsrd >/dev/null && {
			[ "$state" = "1" ] || {
				_log it $funcname daemon alert 'olsrd running, forcing ON'
				state=1
			}
		}

		_log it $funcname daemon info "writing $state to $kernel"
		echo "$state" >"$kernel"
		rm "$file"
	}
}

_netfilter_stop_all_tables()
{
	local funcname='netfilter_stop_all_tables'
	local list custom_chain try work

	for table in mangle filter nat raw; do {
		_log it $funcname daemon info "unloading table $table"
		$IPT --table "$table" -nL >/dev/null || continue
		$IPT --table "$table" -F

		try=10
		while [ $try -gt 0 ]; do {
			try=$(( try - 1 ))
			list="$( $IPT --table "$table" -nL | grep ^'Chain ' | cut -d' ' -f2 )"

			work=
			for custom_chain in $list; do {
				case "$custom_chain" in
					'PREROUTING'|'INPUT'|'FORWARD'|'OUTPUT'|'POSTROUTING')
					;;
					*)
						$IPT --table "$table" -X "$custom_chain"
						work='true'
					;;
				esac
			} done

			[ -z "$work" ] && try=-1
		} done

		$IPT --table "$table" -F

		{
			echo "[start] table '$table'"
			$IPT --table "$table" -nxvL
			echo "[ready] table '$table'"
		} >/dev/console
	} done

	# batman-stuff
	[ -e '/usr/sbin/ebtables' ] && {
		ebtables -t nat    -F
		ebtables -t filter -F
	}
}

_netfilter_mssfix()
{
	local rule='-p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu'

	# do not double apply
	$IPT -nxvL FORWARD | grep -q 'TCPMSS clamp to PMTU' && {
		$IPT -D FORWARD $rule
	}

	$IPT -A FORWARD $rule
}

_netfilter_masquerade_start()
{
	local funcname="netfilter_masquerade_start"
	local devname="${1:-$( _net local_inet_offer )}"
#	local exception="$2"		# fixme! needs source/destination arg
	local device devname statfile
	local userfile="$TMPDIR/user.masq"

	[ -e "$userfile" ] && {
		# TODO: provide clean rollback for masquerade_stop()
		_log it $funcname daemon info "calling '$userfile'"
		command . "$userfile"
	}

	case "$devname" in
		wifi)
			device="$WIFIDEV"
		;;
		wan)
			device="$WANDEV"
		;;
		lan)
			# don't masquerade if configured in /etc/config/system (duplicate masquerading)
			[ "$( uci -q get system.@netfilter[0].lan_masquerading )" = '0' ] && return 0
			device="$LANDEV"
		;;
		pppoe)
			device='ppp+'
		;;
		wwan)
			device='wwan+'
		;;
		'')
			_netfilter masquerade_stop
			[ -e "$userfile" ] || return 0
		;;
		*)
			if _net dev_is_valid "$devname"; then
				device="$devname"
			else
				# e.g. during bootup
				_log it $funcname daemon info "invalid device: '$device'"
				return 1
			fi
		;;
	esac

	mkdir -p '/tmp/NETFILTER'
	statfile="/tmp/NETFILTER/MASQUERADING_$device"

	if [ -e "$statfile" ]; then
		_log it $funcname daemon info "ignoring call, was already done earlier: $statfile"
		return 0
	else
		_log it $funcname daemon info "activating for device $device ($devname)"
	fi

	if bool_true 'system.@system[0].restrict_local'; then
		echo "$IPT -t nat -A POSTROUTING -o $device ! -d $WANNET/$WANPRE -j MASQUERADE" >"$statfile"
		$IPT -t nat -A POSTROUTING -o $device ! -d $WANNET/$WANPRE -j MASQUERADE
	else
		echo "$IPT -t nat -D POSTROUTING -o $device -j MASQUERADE" >"$statfile"
		$IPT -t nat -A POSTROUTING -o $device -j MASQUERADE
	fi

	$IPT -A FORWARD -i $device
	$IPT -A FORWARD -o $device

	case "$CONFIG_PROFILE" in
		tkolleg*)
			$IPT -t nat -I POSTROUTING -s 10.10.0.0/16 -o $LANDEV -j MASQUERADE
			$IPT -t nat -I POSTROUTING -d 10.10.0.10 -j MASQUERADE		# printer
			$IPT -t nat -I POSTROUTING -d 10.10.0.2 -j MASQUERADE		# exNT
		;;
		fparkssee*)
			$IPT -t nat -I POSTROUTING -d 192.168.0.0/16 -j MASQUERADE	# external portfw
		;;
	esac
}

_netfilter_masquerade_stop()
{
	local funcname='netfilter_masquerade_stop'
	local file

	for file in "/tmp/NETFILTER/MASQUERADING"*; do {
		[ -e "$file" ] && {
			_log it $funcname daemon info "exec: $file"
			. "$file"
			rm "$file"
		}
	} done
}

_netfilter_myhna()
{
	local mask="$( uci -q get olsrd.@Hna4[0].netmask )"

	[ -n "$mask" ] && {
		echo "$( uci -q get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $mask )"
	}
}

_netfilter_is_meshnode()	# fixme! better iterate over olsrd-interface, if one is in wifi-adhoc-mode
{
	[ -e "/www/SIMPLE_MESHNODE" ] && return 1	# do not install counters
	[ -z "$WIFIDEV" ] && return 1

	case "$CONFIG_PROFILE" in
		*_adhoc)
			return 0
		;;
		*)
			return 1
		;;
	esac
}

_netfilter_user_list()
{
	local option="$1"
	local list="$2"
	local dir="/tmp/NETFILTER/USER"
	local mac dev speed traffic ip oct123 oct4 list last_action comment vendor hideandseek

	case "$option" in
		v|verbose)
			[ -z "$list" ] && list="$( ls -1 "$dir" 2>/dev/null )"
			[ -z "$list" ] && return 0
			_wifi include

			echo '# show life traffic:'
			echo "# while :; do eval \$( _wifi show_station_traffic \"\$mac\" \$WIFIDEV \$rx \$tx \$up ); sleep 1; done"
			echo "# while :; do _netfilter stats \"\$mac\" kilobytes; sleep 1; done"
			echo '# change shaping:'
			echo "# _netfilter traffic_control_user_change_speed '\$mac'"
			echo "# _netfilter traffic_control_user_del '\$mac'"
			echo

			for mac in $list; do {
				# fetch vendors from internet into cache, avoids wget-trash on each line
				_net mac2vendor "$mac" short >/dev/null 2>&1
			} done

			for mac in $list; do {
				vendor="$( _net mac2vendor "$mac" short )"

				read -r ip 2>/dev/null <"/tmp/NETFILTER/MAC2IP/$mac" || ip="$( _net mac2ip "$mac" )"

				# same length/space for all IP's
				oct4="${ip##*.}"
				oct123="${ip%.*}"
				ip="${oct123}.$( printf "%-3d" $oct4 )"

				dev="$( _net mac2dev "$mac" )"		# can be empty
				dev="$( _net dev_type "$dev" )"
				speed="$( _netfilter traffic_control_show "$mac" )"
				traffic="$( _netfilter stats "$mac" megabytes )"
				traffic="$( printf "%4s" $traffic )mb"
				if _vpn hideandseek_user_probe "$ip"; then
					hideandseek='true'
				else
					hideandseek=
				fi

				if [ "$dev" = "wifi" ]; then
					last_action="$( _wifi get_station_param "$mac" "inactive time" )"
					if [ -n "$last_action" ]; then
						last_action="(last action: $last_action ms)"
					else
						last_action="(not connected)"
					fi
				else
					last_action=
				fi

				echo "$mac : $ip : $dev - $traffic - $speed - ${hideandseek:+HIDE+SEEK} $vendor $last_action" 
			} done
		;;
		*)
			ls -1 "$dir" 2>/dev/null
		;;
	esac
}

_netfilter_user_stats_collect()		# this runs every minute, so speedcode!
{
	local bytes_incoming=0
	local mac line bytes_outgoing uptime rest

	[ -d '/tmp/NETFILTER/USER' ] || return 0

	read -r uptime rest <'/proc/uptime'
	uptime="${uptime%.*}"

	$IPT -t mangle -nxvL FORWARD |
	 while read -r line; do {
		case "$line" in
			*'incoming_'*)
				explode $line
				bytes_incoming=$(( bytes_incoming + $2 ))
				mac="${3#*_}"
			;;
			*"outgoing_"*)
				explode $line
				bytes_outgoing="$2"

				echo "$uptime $bytes_incoming $bytes_outgoing" >>"/tmp/NETFILTER/USER/${mac:-empty_mac}/stats"
				bytes_incoming=0
			;;
		esac
	} done
}

_netfilter_user_reachable()	# output: string/devname e.g. 'wlan0-1'
{
	local funcname='netfilter_user_reachable'
	local mac="$1"
	local ip="$2"
	local dev="$3"
	local maxtry="${4:-5}"
	local line dev_guess devlist dev_try try

	# 00:00:00 = vendor 'xerox', but ofcourse this is invalid and comes from loopback/dhcp
	[ "$mac" = '00:00:00:00:00:00' ] && return 1

	_sanitizer run "$mac" mac check || return 1
	_sanitizer run "$ip"  ip4 check || return 1

	grep -Fsq "$ip " /www/cgi-bin/check_hosts.txt && return 1	# special list of other alien-nodes
	ip neigh show to "$ip" | grep -Fq " dev $WANDEV " && return 1	# no direct logins from WAN

	# TODO: ip can change when called via dnsmasq: e.g. 02:50:43:34:25:bc - if arping fails? refetch ip via 'ip neigh'

	if   [ -n "$DNSMASQ_INTERFACE" ]; then
		dev_guess="$DNSMASQ_INTERFACE"
	elif [ -n "$dev" ]; then
		dev_guess="$dev"
	else
		dev_guess="$( _net ip2dev "$ip" )"
		_log it $funcname daemon info "no DNSMASQ_INTERFACE given, guessed: '$dev_guess'"
	fi

	if   [ "$dev_guess" = "$LANDEV" ]; then
		bool_true 'system.@weblogin[0].force_lan_reachable' && {
			echo "$LANDEV"
			return 0
		}
	elif _net dev_is_wifi "$dev_guess"; then
		case "$dev_guess" in
			'br-mastergate')
				devlist="$WIFI_DEVS"
			;;
			*)
				devlist="$dev_guess"
			;;
		esac

		for dev_try in $devlist; do {
			iw dev "$dev_try" station get "$mac" >/dev/null 2>/dev/null && {
				echo "$dev_guess"
				return 0
			}
		} done

		devlist=
	fi

	# sometimes needed if we have dumb-AP's connected to a central master
	bool_true 'system.@weblogin[0].always_reachable' && {
		if [ -n "$dev_guess" ]; then
			echo "$dev_guess"
			return 0
		else
			_log it $funcname daemon alert "emtpy dev_guess for mac/ip: $mac/$ip"
		fi
	}

	[ -n "$DNSMASQ_INTERFACE" ] || {
		devlist="$( _list uniq "${LANDEV:-$( uci -q get network.lan.ifname )} $WIFI_DEVS" )"
		devlist="$( for dev in $devlist; do test "$dev" = "$dev_guess" || printf '%s' " $dev "; done )"
	}
	devlist="$dev_guess $devlist"

	repair_mac()	# screenscraping 'arping', e.g. '4:70:2:5c:2a:4' (missing leading 0's) -> fixed in busybox 26-May-2016
	{
		local oldIFS="$IFS"; IFS=":"; explode $1; IFS="$oldIFS"
		local tupel new_mac=

		for tupel in $1 $2 $3 $4 $5 $6; do {
			[ ${#tupel} -eq 1 ] && tupel="0${tupel}"
			new_mac="${new_mac}${new_mac:+:}${tupel}"
		} done

		_sanitizer run "$new_mac" lowercase
	}

	for dev in $devlist; do {
		_log it $funcname daemon debug "probing: mac: $mac ip: $ip dev: '$dev'"
		try="$maxtry"
		while [ $try -gt 0 ]; do {
			# root@box:~ arping -c1 -I $LANDEV 10.63.2.40
			# ARPING to 10.63.2.40 from 10.63.2.33 via eth0.1
			# Unicast reply from 10.63.2.40 [0:80:77:0:22:4c] 1.152ms
			# Sent 1 probe(s) (1 broadcast(s))
			# Received 1 replies (0 request(s), 0 broadcast(s))
			#
			# or e.g.:
			# Unicast reply from 192.168.0.1 [0:e:56:0:f:c5] 0.232ms
			#
			# or e.g.: works only with '-D' = 'Duplicated address detection mode'
			# but not all systems do this e.g. LANCOM
			# root@box:~ arping -I wlan0 10.10.183.74 -b
			# ARPING to 10.10.183.74 from 10.10.183.1 via wlan0
			# Sent 7 probe(s) (7 broadcast(s))
			# Received 0 reply (0 request(s), 0 broadcast(s))
			#
			# root@box:~ arping -I wlan0 10.10.183.74 -D
			# ARPING to 10.10.183.74 from 0.0.0.0 via wlan0
			# Unicast reply from 10.10.183.74 [a4:d1:d2:3a:e9:62] 172.323ms
			# Sent 1 probe(s) (1 broadcast(s))
			# Received 1 replies (0 request(s), 0 broadcast(s))
			#
			# !!! the 1st mac is the searched one, the 2nd is ???
			# root@box:~ arping -D -c1 -I $LANDEV 10.63.22.101
			# ARPING to 10.63.22.101 from 0.0.0.0 via eth0.1
			# Unicast reply from 10.63.22.101 [0:4:13:2f:65:cb]for 10.63.22.101 [0:0:1f:79:69:6e] 0.584ms
			# Sent 1 probe(s) (1 broadcast(s))
			# Received 1 replies (0 request(s), 0 broadcast(s))

			# with '-D' = 'Duplicated address detection mode'
			_log it $funcname daemon info "arping -D -c1 -I '$dev' '$ip'"
			line="$( arping -D -c1 -I "$dev" "$ip" | grep -F ':' )" || {
				# not all systems do this e.g. LANCOM
				_log it $funcname daemon info "arping -c1 -I '$dev' '$ip'"
				line="$( arping -c1 -I "$dev" "$ip" | grep -F ':' )"
			}

			if [ -n "$line" ]; then
				line="$( echo "$line" | cut -d'[' -f2 | cut -d']' -f1 )"
				line="$( repair_mac "$line" )"

				if [ "$mac" = "$line" ]; then
					echo "$dev"
					return 0
				else
					_log it $funcname daemon debug "mismatch: $mac != $line"
				fi
			else
				command -v arping >/dev/null || {
					echo "$dev"
					return 0	# fallback
				}
			fi

			try=$(( try - 1 ))
		} done
	} done

	local prio='info'
	[ -z "$devlist" -o "$dev_guess" = "$LANDEV" ] && prio='alert'

	_log it $funcname daemon $prio "no_success: mac: $mac ip: $ip devlist: '$devlist' dev_guess: '$dev_guess'"
	return 1
}

_netfilter_set_arp()
{
	local funcname='netfilter_set_arp'
	local nudmode="$1"	# e.g permanent|reachable|del
	local mac="$2"
	local ip="$3"
	local dev="${4:-$( _net mac2dev "$mac" exact )}"
	local dev_real

	[ -z "$dev" ] && return 1

	case "$mac" in
		'00:00:00:00:00:00')
			return 1
		;;
		*':'*)
			# ok
		;;
		*)
			mac="$( _net ip2mac "$ip" )" || return 1
		;;
	esac

	# TODO: remove code duplicaton, see net_arp_permanent()
	# TODO: del/add/change not implemented in busybox-ip-neigh
	if [ "$nudmode" = 'del' ]; then
		ip neigh del    $ip dev $dev
	else
		[ "$nudmode" = 'permanent' ] && {
			case "$ip" in
				'100.'*)
					return 0	# ugly: do not for roaming
				;;
			esac

			dev_real="$( _netfilter user_reachable "$mac" "$ip" "$dev" )"
			[ "$dev_real" = "$dev" ] || {
				_log it $funcname daemon info "mac/ip $mac/$ip on wrong dev: '$dev' (but is '$dev_real') or not reachable"
				return 1
			}
		}

		ip neigh add    $ip dev $dev lladdr $mac nud $nudmode 2>/dev/null
		ip neigh change $ip dev $dev lladdr $mac nud $nudmode 2>/dev/null
	fi

	return 0
}

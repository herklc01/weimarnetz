#!/bin/sh

ROAMING_DNS='100.64.0.1'	# was: 192.168.0.1
ROAMING_GATEWAY='100.64.0.1'	# was: 192.168.0.1
ROAMING_PRE=10
ROAMING_NET='100.64.0.0'	# octet3: 64...127 = 64 * 256 /24 nets = 16384 IDs)

_net_dummy()
{
	# simulate usage for 'shellcheck'
	echo "$ROAMING_NET $ROAMING_PRE $ROAMING_DNS $ROAMING_GATEWAY"
}

_net_isrouter()
{
	local ip="$1"

	# simple way for ensure, that only real nodes (OLSR/Mid) are valid
	ip route | grep -Fq "$ip via "
}

_net_macplus()
{
	local mac="$1"
	local summand="${2:-1}"
	local oldIFS="$IFS"
	local byte6

	IFS=':'
	explode $mac	# 00:11:22:33:44:9a -> 00 11 22 33 44 9a
	IFS="$oldIFS"

	byte6="$6"				# 9a  (hex)
	byte6=$(( 0x$byte6 + summand ))		# 155 (dec)
	byte6=$(( byte6 % 256 ))		# e.g. 256 -> 0
	byte6="$( printf '%02x\n' "$byte6" )"	# 9b  (hex)

	echo "$1:$2:$3:$4:$5:$byte6"
}

_net_both_ipv4_in_same_subnet()
{
	local addr1="${1%/*}"	# e.g. 100.68.255.61/27	-> 100.68.255.61
	local mask1="${1#*/}"	#			-> 27
	local addr2="${2%/*}"	# e.g. 100.64.0.1/10	-> 100.64.0.1
	local mask2="${2#*/}"	#			-> 10
	local s1 s2 mask

	if [ $mask1 -lt $mask2 ]; then
		mask="$( _net cidr2mask "$mask1" )"
	else
		mask="$( _net cidr2mask "$mask2" )"
	fi

	explode $( echo "$addr1 $mask" | tr '.' ' ' )	# e.g. 10 63 12 1   255 255 255 240
	s1="$(( $1 & $5 )) $(( $2 & $6 )) $(( $3 & $7 )) $(( $4 & $8 ))"
	explode $( echo "$addr2 $mask" | tr '.' ' ' )
	s2="$(( $1 & $5 )) $(( $2 & $6 )) $(( $3 & $7 )) $(( $4 & $8 ))"

	test "$s1" = "$s2"
}

_net_get_rxtx()
{
	local dev="$1"
	local line

	while read -r line; do {
		explode $line

		case "$1" in
			"$dev:")
				echo "bytes_rx=$2;bytes_tx=${10};"
				return
			;;
		esac
	} done <'/proc/net/dev'
}

_net_sensor_type()
{
	local funcname='net_sensor_type'
	local ip="$1"
	local port="${2:-80}"
	local line url proto

	case "$port" in
		443)
			proto='https'
		;;
		*)
			proto='http'
		;;
	esac

	url="$proto://$ip:$port"
	line="$( wget -qO - "$url" | grep '<title>' )"
	case "$line" in
		*'>Sunny WebBox<'*|*'>SMA Energy Meter<'*|*'>FRITZ!Box<'*|*'>Web Image Monitor<'*|\
		*'>SMA .::. Power Reducer Box<'*|*'>Web Server<'*|*'>Solar-Log...<'*)
			echo "$line" | sed -n 's|^.*<title>\(.*\)</title>.*|\1|p'
		;;
		*'>Solar-Log'*)
			echo 'Solar-Log'
		;;
		'')
			# FIXME!
			_log it $funcname daemon info "url1: $url unknown: '$line'"

			url="$proto://$ip:$port/html/en/selectKind.html"
			line="$( wget -qO - "$url" | grep '<title>' )"
			case "$line" in
				*'>WEB&#8217;log Pro Unlimited '*)
					echo 'WebLog Pro Unlimited'
				;;
				'')
					_log it $funcname daemon info "url2: $url unknown: '$line'"
					return 1
				;;
			esac
		;;
		*)
			echo 'generic_webserver'
		;;
	esac
}

_net_list_webservers()		# helper for extrawatt, needs ~26 mins for a /24
{
	local funcname='net_list_webservers'
	local pre="${1:-$WANPRE}"	# FIXME! unused - http://stackoverflow.com/questions/16986879/bash-script-to-list-all-ips-in-prefix
	local octet123="${2:-$WANNET}"	# e.g. 192.168.178.0 or 10.63.4.33
	local range="$pre"
	local ip port mac message sensor_type

# root@EG-labor-AP:~ ipcalc.sh 10.63.4.33 27
# IP=10.63.4.33
# NETMASK=255.255.255.224
# BROADCAST=10.63.4.63
# NETWORK=10.63.4.32
# PREFIX=27
# root@EG-labor-AP:~ ipcalc.sh 10.63.4.0 24
# IP=10.63.4.0
# NETMASK=255.255.255.0
# BROADCAST=10.63.4.255
# NETWORK=10.63.4.0
# PREFIX=24



	[ -z "$octet123" ] && return
	octet123="${octet123%.*}"	# 192.168.178.0 -> 192.168.178

	name='extrawatt'
	range="$( seq 1 254 )"	# FIXME!
	echo "$( date ) - $octet123/$pre"

	for i in $range; do {
		ip="$octet123.$i"

		for port in 22 80 443; do {
			_log it $funcname daemon info "scan '$ip' for port '$port'"
			_net tcp_port_reachable "$ip" "$port" && {
				if [ "$port" = '22' ]; then
					sensor_type='SSH'
				else
					sensor_type="$( _net sensor_type "$ip" "$port" )" || continue
				fi

				mac="$( _net ip2mac "$ip" )"
				message="$name ip: $ANYADR type: $sensor_type"
				echo "OK $ip:$port $message"

				_netfilter portforwarding_add "$WANDEV" "$mac-$port" "$port" "$ip" "$mac" "$message"
			}
		} done
	} done

	echo "$( date ) - ready"
}
					# http://stackoverflow.com/questions/81520/how-to-suppress-terminated-message-after-killing-in-bash
_net_tcp_port_reachable()		# please call with 2>/dev/null otherwise you
{					# always see the 'killed' message from background job
	local funcname='net_tcp_port_reachable'
	local server="$1"		# e.g. 127.0.0.1
	local port="$2"			# e.g. 80
	local check_output="$3"		# pattern or <empty>

	local file="$TMPDIR/$funcname"
	local rc=0
	local pid i

	command -v nc >/dev/null || {
		_log it $funcname daemon info '[ERR] no netcat'
		return 0
	}

	# we can't rely on '-w3' or '-z' because of lobotomized busybox netcat
	( nc "$server" "$port" 2>/dev/null >"$file" || touch "$file.error" ) &
	pid=$!

	if [ -n "$check_output" ]; then
		for i in $( seq 5 -1 1 ); do {
			grep -sq -- "$check_output" "$file" && break
			sleep 1
		} done

		[ $i -gt 0 ] || {
			_log it $funcname daemon info "[ERR] '$( cat "$file" )'"
			rc=1
		}
	else
		i=5
		while [ $i -gt 0 ]; do {
			[ -e "$file.error" ] && {
				rc=1
				break
			}

			sleep 1
			i=$(( i - 1 ))
		} done
	fi

	kill ${pid:-empty_pid} 2>/dev/null
	rm "$file" "$file.error" 2>/dev/null

	return $rc
}

_net_roaming_eventlistener()
{
	local funcname='net_roaming_eventlistener'
	local option="$1"	# e.g. start|stop|restart
	local reason="$2"

	local dev='br-mastergate'
	local pidfile="/tmp/$funcname"
	local pid pids1 pids2 cmdline error i

	_log it $funcname daemon info "option: $option reason: '$reason'"

	if _net dev_is_valid "$dev"; then
		echo "$( date ) $funcname() option: $option reason: '$reason'" >>'/tmp/IWLOG'
	else
		_log it $funcname daemon debug "refusing to $option, missing dev $dev"
		return 1
	fi

	case "$option" in
		'restart')
			_$funcname stop  "$reason"
			_$funcname start "$reason"
		;;
		'start')
			[ -e "$TMPDIR/iwloop_stopping" ] && {
				_log it $funcname daemon info "[ERR] existing '$TMPDIR/iwloop_stopping', will not start"
				return 1
			}

			for pid in $( pidof iw ); do {
				read -r cmdline <"/proc/$pid/cmdline"
				[ "$cmdline" = 'iwevent' ] && {
					_log it $funcname daemon info "[ERR] too much 'iw' instances, will not start"
					return 1
				}
			} done

			/usr/sbin/cron.wireless_events &
			echo "$!" >"$pidfile"
		;;
		'stop')
			touch "$TMPDIR/iwloop_stopping"

			i=10
			error=
			pids1="$( pidof iw )" && {
				touch "$TMPDIR/IWLOOP_RESPECT_REGSET"

				while pids2="$( pidof iw )"; do {
					# FIXME! special 'command' for listener
					# FIXME! (really 2 calls needed...)
					iw reg set 00
					iw reg set US
					i=$(( i - 1 ))
					[ $i -eq 0 ] && break

					_log it $funcname daemon info "stop: still running 'iw' (pid: $pids2)"
					sleep 1
				} done

				rm "$TMPDIR/IWLOOP_RESPECT_REGSET"

				if   [ $i -eq 0 -a "$pids1" = "$pids2" ]; then
					error='err1'
					_watch hanging_command iw
					_watch hanging_command iw
				elif [ -n "$pids2" ]; then
					error='err2'
					_log it $funcname daemon alert "stop: still running 'iw'-instance $pids2"
					read -r pid <"$pidfile"
					kill $pid
				else
					rm "$TMPDIR/iwloop_stopping"
					return 0
				fi

				[ -n "$error" ] && _wifi phy_restart "$WIFIDEV" "$error $funcname stop"
			}

			rm "$TMPDIR/iwloop_stopping"
		;;
	esac
}

_net_roaming_debug()
{
	local mode="$1"		# new|del
	local unixtime="$2"
	local mac="$3"
	local ip="$4"
	local freq="$5"
	local signal="$6"	# -80 or 'early'
	local wifidev="$7"
	#
	local server="$( _weblogin authserver )"
	local query='action=roaming_mac_action'
	local url="http://$server/cgi-bin-collect.sh?$query"
	local params="&mode=$mode&unixtime=$unixtime&mac=$mac&ip=$ip&freq=$freq&signal=$signal&wifidev=$wifidev&node=$NODENUMBER&hostname=$HOSTNAME"
	local answer="$( _curl it "${url}${params}" )"

	case "$answer" in
		'OK')
		;;
		*)
			echo >>$SCHEDULER_NEXTRUN "_net roaming_debug $mode $unixtime $mac '$ip' $freq $signal $wifidev"
		;;
	esac
}

_net_roaming_fetch_cache()
{
	local file="$TMPDIR/roaming"
	local url authserver query ip

	# only if roaming enabled
	_net dev_is_valid 'br-mastergate' || return 0

	if _weblogin authserver is_myself; then
		[ -e "$file" ] || {
			ip="$( _olsr neigh_random_get )" && {
				query='action=roaming_getlist'
				url="http://$ip/cgi-bin-collect.sh?$query"
				_curl it "$url" >"$file.tmp"

				grep -n '' "$file.tmp" | sort -rn | cut -d: -f2- >"$file"
				rm "$file.tmp"
			}
		}
	else
		authserver="$( _weblogin authserver )"
		query='action=roaming_getlist'
		url="http://$authserver/cgi-bin-collect.sh?$query"
		_curl it "$url" >"$file"
	fi
}

_net_roaming_mac2ip()
{
	local funcname='net_roaming_mac2ip'
	local mac="${1:-no_mac_given}"
	local action="$2"			# delete_from_local_cache|local_only
	local ip="$3"				# only for deleting
	local file="$TMPDIR/roaming"
	local file_dhcp="$TMPDIR/roaming_dhcp"
	local line url authserver query method

	[ -e "$file" ] || _net roaming_fetch_cache

	get_local()
	{
		if line="$( grep -s ^"$mac" "$file_dhcp" )"; then
			method="'$file_dhcp'"
		elif _weblogin authserver is_myself; then
			# use 'tac'
			line="$( grep -sn '' "$file" | sort -rn | cut -d: -f2- | grep ^"$mac" )" && {
				method="'$TMPDIR/roaming' (i'am the authserver)"
			}
		else
			line="$( grep -s ^"$mac" "$file" )" && {
				method="'$file'"
			}
		fi
	}

	# format: mac ip expires
	if   [ "$action" = 'delete_from_local_cache' ]; then
		sed -i "s/^$mac $ip/# $mac $ip/g" "$file"
	elif get_local; then
		explode $line
		ip="$2"
		_log it $funcname daemon info "[OK] mac->IP: $mac -> $ip from $method"
		echo "$ip"
	elif [ "$action" = 'local_only' ]; then
		return 1
	else
		_weblogin authserver is_myself || {
			authserver="$( _weblogin authserver )"
			query="action=roaming_querymac&mac=$mac"
			url="http://$authserver/cgi-bin-collect.sh?$query"

			ip="$( _curl it "$url" )"
			test -n "$ip" && {
				_log it $funcname daemon info "[OK] mac->IP: $mac -> $ip from '$url'"
				echo "$ip"
			}
		}

		# TODO: normal waiting for ARP
	fi
}

_net_roaming_cleanup_cache()
{
	local file="$TMPDIR/roaming"
	local unixtime="$( _system date unixtime )"
	local line

	[ -e "$file" ] || return 0

	# TODO: keep newest entry of same mac
	# 00:21:00:ce:c5:8f 192.168.2.3 1433623803
	# 00:21:00:ce:c5:8f 192.168.2.4 1433623818
	# 00:21:6a:32:7c:1c 192.168.2.61 1433621675
	# 00:21:6a:32:7c:1c 192.168.23.61 1433616647

	while read -r line; do {
		# format: mac ip expires
		explode ${line:-0 0 0}
		test $3 -gt $unixtime && echo "$line"
	} done <"$file" >"$file.tmp.$$"

	# FIXME! double write access, e.g. from collect.sh?
	mv "$file.tmp.$$" "$file"
}

_net_roaming_report_new()
{
	local mac="$1"
	local ip="$2"
	local expires="$3"		# e.g. DNSMASQ_LEASE_EXPIRES (unixtime)
	# TODO: signal? channel?

	local file="$TMPDIR/roaming"
	local authserver url query answer

	if _weblogin authserver is_myself; then
		echo "$mac $ip $expires" >>"$file"
		echo >>$SCHEDULER '_net roaming_cleanup_cache'
	else
		authserver="$( _weblogin authserver )"
		query="action=roaming_add&mac=$( _sanitizer run "$mac" urlvalue )&ip=$ip&expires=$expires"
		url="http://$authserver/cgi-bin-collect.sh?$query"
		answer="$( _curl it "$url?$query" )"

		case "$answer" in
			'OK'*)
				# TODO: fetch recent list
			;;
			*)
				echo >>$SCHEDULER_NEXTRUN "_net roaming_report_new $mac $ip $expires"
			;;
		esac
	fi
}

_net_track_ap()		# helper/debug for a roaming laptop -> move to _wifi()?
{
	local dev="${1:-$WIFIDEV}"
	local gateway_ip url apmac last unixtime_connstart elapsed diff connection_duration channel channel_last
	rm -f "/tmp/MAC_"* "$TMPDIR/MAC2HOSTNAME_"* 2>/dev/null

	say()
	{
		local text="$1"
		local channel="$2"
		local file="$TMPDIR/say.$$.wav"

		command -v 'pico2wave' >/dev/null || return 1
		command -v 'aplay' >/dev/null || return 1

		# TODO: EG-labor-AP -> "E G - Labor - AP"
		pico2wave --lang 'de-DE' --wave "$file" "Kanal $channel - $text"
		aplay "$file" 2>/dev/null
		rm "$file"
	}

	get_gateway_ip()
	{
		_sanitizer run "$( ip route list exact '0.0.0.0/0' | head -n1 )" ip4
	}

	get_apmac()
	{
		explode $( iw dev "$dev" station dump | grep ^'Station' )
		echo "${2:-unconnected}"
	}

	get_signal()
	{
		explode $( iw dev "$dev" station dump | grep 'signal:' )
		echo "${2:-0}"
	}

	bandroam_happend()
	{
		local mac1="$1"					# 66:66:b3:de:d9:eb
		local mac2="$2"					# 66:66:b3:de:d9:ea
		local s1 s2

		explode $( echo "$mac1" | tr ':' ' ' )
		s1=$(( 0x$2 + 0x$3 + 0x$4 + 0x$5 + 0x$6 ))	#    66 b3 de d9 eb
		explode $( echo "$mac2" | tr ':' ' ' )
		s2=$(( 0x$2 + 0x$3 + 0x$4 + 0x$5 + 0x$6 ))	#    66 b3 de d9 ec

		[ $(( s1 - s2 )) -eq 1 -o $(( s2 - s1 )) -eq 1 ]
	}

	get_hostname()
	{
		local mac="$1"
		local url="$2"
		local bandroam="$3"
		local i=10
		local hostname mac_after

		if [ -z "$mac" ]; then
			return 1
		else
			read -r hostname 2>/dev/null <"$TMPDIR/MAC2HOSTNAME_$mac" && {
				echo "$hostname"
				[ $connection_duration -eq 0 ] && say "neuer Router ist: $hostname"
				return 0
			}
		fi

		# wait for good
		[ $connection_duration -lt 15 ] && return 0

		while [ -z "$hostname" ]; do {
			_log it get_hostname daemon info "try: $i hostname: $url"
			hostname="$( _curl it "$url" 3 )" || sleep 1

			i=$(( i - 1 ))
			[ $i -eq 0 ] && {
				echo 'unknown_hostname'
				return 1
			}
		} done

		mac_after="$( get_apmac )"
		[ "$mac" = "$mac_after" ] || {
			echo 'AP changed'
			return 1
		}

		hostname="$( _sanitizer run "$hostname" firstline hostname )"
		[ -z "$bandroam" ] && {
			say "neuer Router ist: $hostname" "${channel:-keiner_ZWO}"
		}

		# FIXME! make sure we have not changed the ap
		echo "$hostname" >"$TMPDIR/MAC2HOSTNAME_$mac"
		echo "$hostname"
	}


	# show ping loss?
	while true; do {
		bandroam=
		gateway_ip="$( get_gateway_ip )"
		url="http://$gateway_ip/cgi-bin-tool.sh?OPT=hostname"
		apmac="$( get_apmac "$@" )"	# SC2119/SC2120

		if [ "$apmac" = 'unconnected' ]; then
			[ -e "$TMPDIR/unconnected" ] || {
				touch "$TMPDIR/unconnected"
				say "Verbindungsabbruch"
			}

			sleep 1
			continue
		else
			[ -e "$TMPDIR/unconnected" ] && rm "$TMPDIR/unconnected"
		fi

		test "$apmac" = "$last" || {
			unixtime_connstart="$( _system date unixtime )"
			channel="$( _wifi channel "$WIFIDEV" )"
			echo

			if bandroam_happend "$last" "$apmac"; then
				bandroam='true'
				echo "$( date ) bandroam: $last -> $apmac"
				say '' "${channel_last:-0} zu $channel"
			else
				echo "$( date ) new: $apmac"
				say "Achtung, der Zugangspunkt hat gewechselt." "${channel:-Verbindung verloren}"
			fi

#			rm "$TMPDIR/MAC2HOSTNAME_$last" 2>/dev/null	# see get_hostname()
			connection_duration=0
		}
		last="$apmac"
		channel_last="$channel"

		hostname='???'
		[ -n "$gateway_ip" -a -n "$apmac" ] && hostname="$( get_hostname "$apmac" "$url" "$bandroam" )"
		diff=$(( $( _system date unixtime ) - ${unixtime_connstart:-0} ))
		elapsed="$( _stopwatch seconds2humanreadable "$diff" pedantic )"
		# SC2119/SC2120
		printf '%b%s' "$( date )      $apmac ch$channel/$( get_signal "$@" ) : $hostname ($elapsed)        \r"

		connection_duration=$(( connection_duration + 1 ))
		sleep 1
	} done
}

_net_count_wireless()
{
	local wifi_clients_sum=0
	local file clients

	# build during watch_wifistuff()
	for file in /tmp/wifi_hasclients_*; do {
		case "$file" in
			*'_max'|*'_*')
			;;
			*)
				read -r clients <"$file"
				wifi_clients_sum=$(( wifi_clients_sum + clients ))
			;;
		esac
	} done

	echo "$wifi_clients_sum"
}

_net_count_wired()
{
	local funcname='net_count_wired'
	local list_noclients line dev ip mac
	local i=0

	# see cisco_collect() IMPROVE!
	# collect lowercase mac's of cisco routers
	list_noclients="$(
		grep -s ' MAC ' '/tmp/cisco-AP'* | cut -d' ' -f5 | while read -r line; do {
			line="$( _sanitizer run "$line" lowercase )"
			printf '%s' " $line"
		} done
	)"

	# /proc/net/arp is not always correct
	ip neigh show >"/tmp/$funcname"

	while read -r line; do {
		explode $line
		ip="$1"
		dev="$3"
		mac="$5"

		case "$mac" in
			*':'*)
				_list contains_element "$list_noclients" "$mac" && continue
			;;
			*)
				# no valid arp
				continue
			;;
		esac

		case "$ip" in
			*'::'*)
				continue
			;;
		esac

		case "$dev" in
			$LANDEV|$WANDEV)
				# list all wired, which are not OLSR, see olsr_build_tables()
				grep -Fq "REMOTE=$ip;" '/tmp/OLSR/LINKS.sh' || i=$(( i + 1 ))
			;;
		esac
	} done <"/tmp/$funcname" && rm "/tmp/$funcname"

	echo "$i"
}

_net_my_isp()		# TODO: http://www.utrace.de/api.php
{
	local option="$1"
	local cachefile="$TMPDIR/myisp"
	local isp method

	[ "$option" != 'cached' -o ! -e "$cachefile" ] && {
		m1()
		{
			_curl it 'http://www.spyber.com' | grep -F 'My Host :' | cut -d'<' -f1
		}

		m2()
		{
			_curl it 'http://www.whoismyisp.org' | sed -n "/ (ISP) is /s/^.*'\(.*\)'.*/\1/p"
		}

		for method in m1 m2; do {
			isp="$( $method )"
			[ -n "$isp" ] && {
				echo "$isp" >"$cachefile"
				break
			}
		} done
	}

	[ -e "$cachefile" ] && read -r isp <"$cachefile"
	echo "${isp:-unknownISP}"
}

_net_fulltrace()
{
	local destination="$1"
	local ip interface speed output mbit nexthop
	local ip_list=

	if [ -n "$destination" ]; then
		nexthop="$destination"
	else
		# '?' or '10.63.160.161 LAN 4369'
		explode $( _wifi speed cached verbose )
		nexthop="$1"
		interface="$2"
		speed="${3:-0}"
	fi

	[ "$nexthop" = '?' ] && {
		read -r nexthop <'/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY'
	}

	case "$interface" in
		WAN|LAN)
			speed=12500	# 100 mbit FIXME! - not true with a transparent wifi bridge
			ip="$LANADR"
		;;
		*)
			ip="$WIFIADR"
		;;
	esac

	mbit=$(( speed * 8 / 1000 ))
	ip_list="$ip_list $nexthop "
	echo "ip: $ip nexthop: $nexthop interface: $interface speed: $speed kilobyte/s = $mbit megabit/s"

	while true; do {
		if [ "$1" = '?' ]; then
			output='?'
		else
			output="$( _tool remote "$1" speed_nexthop )"
			ip="$1"
		fi

		case "$output" in
			'?'|'')
				echo "ready: '$output' (stop at $ip)"
				return 0
			;;
			*)
				case " $ip_list " in
					" $ip ")
						# avoid loop: maintain list of already asked nodes
						# and abort if the same comes again
						echo "loop/abort: $ip"
						return 1
					;;
				esac

				# 10.63.160.161 LAN 4369
				explode $output
				nexthop="$1"
				interface="$2"
				speed="$3"

				case "$interface" in
					WAN|LAN)
						speed=12500	# 100 mbit FIXME! - not true with a transparent wifi bridge
					;;
				esac

				mbit=$(( speed * 8 / 1000 ))
				ip_list="$ip_list $nexthop "
				echo "ip: $ip nexthop: $nexthop interface: $interface speed: $speed kilobyte/s = $mbit megabit/s"
			;;
		esac
	} done
}

_net_arp_reset()
{
	local mac_wish="$1"	# <empty> = all
	local line mac

	while read -r line; do {
		# 10.63.196.161  0x1  0x6  00:10:75:2d:80:e1  *  eth0.1
		explode $line
		mac="$4"

		_net ismacaddress "$mac" || continue

		[ "$mac_wish" = "$mac" -o -z "$mac_wish" ] && {
			_net arp_permanent "$1" "$mac" "$6" 'reachable'
		}
	} done <'/proc/net/arp'
}

_net_show_traffic()
{
	local iface="$1"
	local interval="${2:-1}"
	local bytes_rx bytes_tx old_rx old_tx diff_rx diff_tx mbit_rx mbit_tx percent_tx percent_rx txt change
	local max_tx=1 max_rx=1

	[ -z "$iface" ] && {
		# default via 10.63.99.61 dev eth0.2  metric 2 onlink
		explode $( ip route list exact '0.0.0.0/0' | head -n1 )
		while test ! "$1" = 'dev' -a -n "$1"; do shift; done
		iface="$2"
	}

	local pre="$( _net dev2name "$iface" )/$iface"

	while true; do {
		eval $( _net get_rxtx "$iface" )	# bytes_rx | bytes_tx

		divisor_valid "$interval" || interval=1
		diff_rx=$(( ( bytes_rx - ${old_rx:-0} ) / interval ))	# divisor_valid
		diff_tx=$(( ( bytes_tx - ${old_tx:-0} ) / interval ))	# divisor_valid
		mbit_rx=$(( diff_rx / 80000 ))
		mbit_tx=$(( diff_tx / 80000 ))		# FIXME for small values, e.g. 0.25mbit show only '0'
		old_rx=$bytes_rx
		old_tx=$bytes_tx

		change=
		test $diff_rx -gt $max_rx -a -n "$txt" && { max_rx=$diff_rx; change='newMAX'; }
		test $diff_tx -gt $max_tx -a -n "$txt" && { max_tx=$diff_tx; change='newMAX'; }
		percent_tx="$( _math percentof $diff_tx $max_tx )"
		percent_rx="$( _math percentof $diff_rx $max_rx )"

		txt="$pre: rx/tx = down/upload: $diff_rx | $diff_tx [bytes/s] = $mbit_rx/$mbit_tx [mbit/s] = ${percent_rx%.*}/${percent_tx%.*}% $change"
		_sanitizer run "$txt" number_humanreadable
		echo

		sleep $interval
	} done
}

_net_get_external_ip()		# FIXME! add IPv6 and rename to 'ip4'
{				# FIXME! add override for 'IPv6 only' and 20 ports IPv4-portfw
	local url_user="$1"
	local ip url
	local url_default="$( uci -q get system.@monitoring[0].url )/getip/"
	local url_fallback1="http://intercity-vpn.de/networks/liszt28/getip/"	# if default is unset
	local url_fallback2='http://api.ipify.org'
	local list_url="$url_user $url_default $url_fallback1 $url_fallback2"
	local timeout=6

	for url in $list_url; do {
		ip="$( _curl it "$url" $timeout )"

		_sanitizer run "$ip" ip4 check && {
			echo "$ip"
			return 0
		}
	} done
}

_net_ping_getlatency()
{
	local server="$1"	# e.g. <ip> or <host>
	local pings="${2:-3}"

	# round-trip min/avg/max = 24.638/24.638/24.638 ms	// busybox
	# or:                      ^^^^^^^^^^^^^^^^^^^^
	# 3 packets transmitted, 0 packets received, 100% packet loss
	#                       ^^^
	# rtt min/avg/max/mdev = 33.415/33.415/33.415/0.000 ms	// debian
	# or: <empty>
	explode $( ping -q -c${pings} -W1 "$server" 2>/dev/null | tail -n1 )

	# bad return on error
	test -n "$4" -a "$4" != '0' &&	{
		# round-trip min/avg/max = 15.887/24.931/42.406 ms
		# -> 15.887/24.931/42.406 -> 15 887 24 931 42 406
		local oldIFS="$IFS"; IFS='[/.]'; explode $4; IFS="$oldIFS"

		# output 'average' round trip time: 24.931 -> 24
		echo "$3"
	}
}

_net_ping6()
{
	local dev="${1:-$LANDEV}"		# or a mac
	local option="${2:-$LANDEV}"		# or dev
	local line mac address

	# e.g. dev = macaddress
	_net dev_is_valid "$dev" || {
		mac="$dev"
		dev="$option"
		line="$( _net mac2linklocal "$mac" )"
		address="${line}%$dev"

		ping6 -c1 $address

		echo "ping6 $address"
		echo "ssh $address"
		echo "curl 'http://[$address]/robots.txt'	# needs v7.37.1+"
		echo "wget -O - 'http://[$address]/robots.txt'"
		echo "wget -O - 'http://[$address]/cgi-bin-tool.sh?OPT=startshell'"
		echo "telnet $address"

		return 0
	}

	# FIXME!
	# ping for ~5 secs and remove myself + double

	# option '-L' ("Suppress loopback of multicast packets") is not supported by busybox
	# ip=$(ping6 -L -c 1 -W 2 ff02::1%$iface | grep "^64 bytes" | head -n1 | cut -d ' ' -f 4 | sed "s/:$/%$iface/") ;echo ${ip:-no_reply}
	# idea: filter out own fe80::address from $dev

	# root@Probenraum:~ ping ff02::1
	# PING ff02::1 (ff02::1): 56 data bytes
	# 64 bytes from ff02::1: seq=0 ttl=64 time=0.481 ms
	# 64 bytes from ff02::1: seq=0 ttl=64 time=0.936 ms (DUP!)
	# 64 bytes from ff02::1: seq=1 ttl=64 time=0.554 ms
	# 64 bytes from ff02::1: seq=1 ttl=64 time=1.371 ms (DUP!)
	#
	# -> look at 'ip neigh'

	# e.g. 64 bytes from fe80::6670:2ff:fed3:240a: seq=0 ttl=64 time=2.187 ms
	ping -6 -c1 "ff02::1%$dev" | grep ^'64 bytes' | cut -d' ' -f4 | while read -r line; do {
		# remove last ":"
		line="$( echo "$line" | sed 's/:$//' )"
		# suppress my own
		ip address show dev "$dev" | grep -q "inet6 $line/64" || echo "$line"
	} done
}

_net_dns_resolvconf_change_first_nameserver()
{
	local funcname='net_dns_resolvconf_change_first_nameserver'
	local ip_wish="$1"	# <IP> or 'remove'
	local option="$2"	# e.g. simple

	local file='/tmp/resolv.conf'
	local temp='/tmp/resolv.tmp'
	local replaced='false' line
	local testserver='intercity-vpn.de'

	[ "$ip_wish" = 'remove' ] || {
		# FIXME! ip_wish is ignored with musl - https://dev.openwrt.org/ticket/18333
		# http://lists.busybox.net/pipermail/busybox/2014-November/081960.html
		nslookup "$$.$testserver" "$ip_wish" 2>/dev/null >/dev/null || {
			_log it $funcname daemon alert "DNS fails via $ip_wish - abort"
			return 1
		}
	}

	while read -r line; do {
		case "$line" in
			'nameserver '*)
				if [ "$replaced" = 'false' ]; then
					if [ "$line" = "nameserver $ip_wish" ]; then
						# first entry is already our wish, no action needed
						return 0
					else
						[ "$ip_wish" = 'remove' ] || {
							_log it $funcname daemon alert "$file: nameserver $ip_wish"
							echo "nameserver $ip_wish"
						}

						if [ "$option" = 'simple' ]; then
							_log it $funcname daemon alert "$file: nameserver 127.0.0.1"
							echo 'nameserver 127.0.0.1'
							break
						else
							_log it $funcname daemon alert "$file: $line"
							echo "$line"
							replaced='true'
						fi
					fi
				else
					if [ "$line" = "nameserver $ip_wish" ]; then
						# no action, ignore the old entry
						:
					else
						_log it $funcname daemon alert "$file: $line"
						echo "$line"
					fi
				fi
			;;
			*)
				_log it $funcname daemon alert "$file: $line"
				echo "$line"
			;;
		esac
	} done <"$file" >"$temp"

	mv "$temp" "$file"
}

_net_mac2linklocal()	# SENSE: mac-address to IPv6 fe80::*
{
	local mac="$1"

	case "$mac" in
		*':'*)
		;;
		*)
			# 112233445566 -> 11:22:33:44:55:66
			mac="$( echo "$mac" | sed 's/\(\w\w\)\(\w\w\)\(\w\w\)\(\w\w\)\(\w\w\)\(\w\w\)/\1:\2:\3:\4:\5:\6/g' )"
		;;
	esac

	local oldIFS="$IFS"; IFS=':'; explode $mac; IFS="$oldIFS"
	printf "fe80::%x:%x:%x:%x\n" $(( 0x${1}${2} ^ 0x200 )) 0x${3}ff 0xfe${4} 0x${5}${6}
}

_net_ip_reachable()
{
	local funcname='net_ip_reachable'
	local ip="$1"
	local max_attempts="${2:-30}"		# must be >1 or 'ping'
	local dev="$3"				# or maxtry in 'ping'-mode
	local pingtest line dev_list dev_guessed

	if [ "$max_attempts" = 'ping' ]; then
		max_attempts="${dev:-3}"
		if _net dev_is_valid "$max_attempts"; then
			dev="$max_attempts"
			max_attempts=3
		else
			[ -z "$dev" ] && {
				dev="$( _net ip2dev "$ip" )"
				dev_guessed='true'
			}
		fi

		pingtest="$ip"
	else
		pingtest='127.0.0.1'		# always is good
		[ -z "$dev" ] && {
			dev="${dev:-$( _net ip2dev "$ip" )}"
			dev_guessed='true'
		}
	fi

	dev_list="${dev:-does_not_exist}"

	case "$dev" in
		'br-mastergate')
			_log it $funcname daemon info "dev '$dev' simulating OK"
			return 0
		;;
		'')
			[ "$pingtest" = "$ip" ] || {
				_log it $funcname daemon info '[ERR] empty devname'
				return 1
			}
		;;
		'wlan'*)
			# TODO: ip2dev() net reliable for multiradio - introduce $WIFI_DEVS_ADHOC?
			# without known arp-entry, we must check all adhoc-channels
			[ "$dev_guessed" = 'true' ] && {
				for dev in $dev $WIFI_DEVS; do {
					iw dev "$dev" info | grep -q 'type IBSS'$ && dev_list="$dev_list $dev"
				} done
				dev_list="$( _list uniq "$dev_list" )"
			}
		;;
		*)
			_net dev_is_valid "$dev" || return 1

			ip link show dev "$dev" | grep -Fq 'NOARP' && {
				_log it $funcname daemon info "dev '$dev' is valid but not ARPable - assuming OK"
				return 0
			}
		;;
	esac

	echo "$funcname" >'/tmp/CRON_OVERLOAD'

	arping_method1()
	{
		local dev="$1"
		local ip="$2"
		local line="$( arping -D -c1 -I "$dev" "$ip" )"

		case "$line" in
			*"Unicast reply from $ip "*|*'Received 1 replies'*|*' 1 packets received'*|*' 0% packet loss'*)
				return 0
			;;
			*)
				return 1
			;;
		esac
	}

	arping_method2()
	{
		local dev="$1"
		local ip="$2"
		local line="$( arping -c1 -I "$dev" "$ip" )"

		case "$line" in
			*"Unicast reply from $ip "*|*'Received 1 replies'*|*' 1 packets received'*)
				return 0
			;;
			*)
				return 1
			;;
		esac
	}

	for max_attempts in $( seq "$max_attempts" -1 1 ); do {
		for dev in $dev_list; do {
			# arping also returns with 0, without reply (so we grep the output)
			#
			# root@feld-sollstedt:~ arping -D -c 1 -I eth0 10.10.249.33
			# ARPING to 10.10.249.33 from 0.0.0.0 via eth0
			# Sent 1 probe(s) (1 broadcast(s))
			# Received 0 reply (0 request(s), 0 broadcast(s))
			# root@feld-sollstedt:~ echo $?
			# 0

			# switch -f seems not POSIX
			# root@LEDE:~ arping -D -c 3 -I eno1 141.54.159.254
			# !!!       0% packet loss (0 extra)

			# ARPing 2.14, by Thomas Habets <thomas@habets.se>
			# root@LEDE:~ arping -c 1 -I eno1 141.54.159.254
			# ARPING 141.54.159.254
			# 60 bytes from 14:10:54:15:92:54 (141.54.159.254): index=0 time=4.124 msec
			#
			# --- 141.54.159.254 statistics ---
			# 1 packets transmitted, 1 packets received,   0% unanswered (0 extra)
			# rtt min/avg/max/std-dev = 4.124/4.124/4.124/0.000 ms


			if   arping_method1 "$dev" "$ip"; then
				rm -f '/tmp/CRON_OVERLOAD'
				ping -c1 "$pingtest" >/dev/null
				return
			elif arping_method2 "$dev" "$ip"; then
				rm -f '/tmp/CRON_OVERLOAD'
				ping -c1 "$pingtest" >/dev/null
				return
			else
				if [ "$pingtest" = '127.0.0.1' ]; then
					command -v arping >/dev/null || {
						rm -f '/tmp/CRON_OVERLOAD'
						return 0	# FIXME! dirty fallback
					}
				else
					ping -c1 "$pingtest" >/dev/null && {
						rm -f '/tmp/CRON_OVERLOAD'
						return 0
					}
				fi

				line="$( ip neigh show to "$ip" )"
				_log it $funcname daemon info "arping: $ip dev: $dev list: '$dev_list' line: '$line' try: $max_attempts"
			fi
		} done
	} done

	rm -f '/tmp/CRON_OVERLOAD'
	return 1
}

_net_text2port()
{
	local text="$1"
	local position char ascii sum value

	while [ ${position:=1} -le ${#text} ]; do {
		char="$( echo "$text" | cut -b $position )"
		ascii="$( printf '%d' "'$char" )"
		value=$(( ( ascii * 17 ) / 3 ))		# nearly no collisions in testsuite: TODO: where is it?
		sum=$(( ${sum:-1025} + value ))
		position=$(( position + 1 ))
	} done

	[ ${sum:=1025} -gt 65535 ] && sum=65535
	echo "${sum:-1025}"
}

_net_refresh_dnshosts()		# this is mostly for getting recent values from nameservice-plugin of olsr
{
	local funcname='net_refresh_dnshosts'
	local pid cmdline line
	local list_pids="$( pidof dnsmasq )"

	# TODO: has_changed '/var/run/hosts_olsr' || return 0

	for pid in $list_pids; do {
		read -r cmdline <"/proc/$pid/cmdline"

		case "$cmdline" in
			*'fakedns'*)
			;;
			*)
				while read -r line; do {
					case "$line" in
						'PPid:'*)
							explode $line

							# it only works with the 'nobody' dnsmasq,
							# which has PPid = 1
							if [ "$2" = '1' ]; then
								# logging stats
								_log it $funcname daemon info "sending SIGUSR1 and HUP to $pid/nobody"
								kill -SIGUSR1 $pid
								# rereads /etc/hosts + /etc/ethers + /var/run/hosts_olsr
								# and calls dhcp_old via dhcp-script
								kill -HUP $pid

								return 0
							else
								break
							fi
						;;
					esac
				} done <"/proc/$pid/status"
			;;
		esac
	} done
}

_net_dhcp_lease_filename()
{
	local file

	if   [ -e '/tmp/dhcp.leases' ]; then		# openwrt
		file="/tmp/dhcp.leases"
	elif [ -e '/var/run/dhcp.leases' ]; then	# freifunk-firmware
		file="/var/run/dhcp.leases"
	else
		file="$( uci -q get dhcp.@dnsmasq[0].leasefile )"
	fi

	[ -z "$file" -o ! -e "$file" ] && {
		file='/tmp/fake_dhcp_lease_file'
		touch "$file"
	}

	echo "$file"
}

_net_dhcp_lease_show()
{
	cat "$( _net dhcp_lease_filename )"
}

_net_dhcp_lease_remove()
{
	local funcname='net_dhcp_lease_remove'
	local mac="$1"
	local line pid
	local dhcp_lease_file="$( _net dhcp_lease_filename )"
	local tempfile="/tmp/dhcp_leases_$$"

	# typical leasfile:
	# 1397204975 f8:e0:79:de:e9:fc 10.10.12.6 anonymous-lan6-n12 *
	# 1397204779 e4:ce:8f:0e:4f:9e 10.10.12.5 anonymous-lan5-n12 01:e4:ce:8f:0e:4f:9e
	while read -r line; do {
		case "$line" in
			*" $mac "*)
			;;
			*)
				echo "$line"
			;;
		esac
	} done <"$dhcp_lease_file" >"$tempfile"

	mv "$tempfile" "$dhcp_lease_file"

	pid="$( _system get_first_pid dnsmasq )"
	_log it $funcname daemon info "sending SIGUSR1 to pid $pid"
	kill -SIGUSR1 $pid	# stats to syslog

	echo >>$SCHEDULER '/etc/init.d/dnsmasq restart'
}

_net_mac2vendor()
{
	local funcname='net_mac2vendor'
	local oui="$1"					# ab12cd | AB12CD | 1122334455AA | 11-22-33-44-55-aa | 11:22:33:44:55:AA
	local option="$2"				# e.g. 'short'
	local url="http://$MONITORING_SERVERIP/oui"	# see /api.txt

	# OUI = O.rganizationally U.nique I.dentifier

	if   [ ${#oui} -eq 6 -o ${#oui} -eq 12 ]; then
		:
	elif [ ${#oui} -eq 17 ]; then
		oui="$( echo "$oui" | tr -d ':' )"
		oui="$( echo "$oui" | tr -d '-' )"
		[ ${#oui} -eq 12 ] || return 1
	else
		[ ${#oui} -eq 0 ] && return 1
		oui="$( _sanitizer run "$oui" mac hex lowercase length:6 )"
		[ ${#oui} -eq 6 ] || return 1
	fi

	# 112233445566
	case "$oui" in
		'ffffff'|'ffffffffffff')
			echo 'locally_administered (802.11p OCB)'
		;;
		# test 2nd bit of first byte: http://de.wikipedia.org/wiki/MAC-Adresse#Vergabestelle
		# for DEC in $(seq 0 255); do HEX="$( printf "0x%X\n" $DEC )"; test $(( HEX & 2 )) -eq 2 && echo $HEX; done | cut -b4- | sort -u
		?'2'*|?'3'*|?'6'*|?'7'*|?'a'*|?'b'*|?'e'*|?'f'*|?'A'*|?'B'*|?'E'*|?'F'*)
			echo 'locally_administered'
		;;
		*)
			local cache="/tmp/oui/$oui"
			[ -e "$cache" ] || {
				mkdir -p '/tmp/oui'
				url="$url/$( echo "$oui" | cut -b 1,2 )/$( echo "$oui" | cut -b 3,4 )/$( echo "$oui" | cut -b 5,6 )"
				_sanitizer run "$( _curl it "$url" 5 2>/dev/null )" shellsafe >"$cache"

				[ $( _file size "$cache" ) -eq 0 ] && {
					_log it $funcname daemon info "download '$url' failed or empty data"
					rm "$cache"
					return 1
				}
			}

			if [ "$option" = "short" ]; then
				head -n1 "$cache"
			else
				cat "$cache"
			fi
		;;
	esac
}

_net_ip4_is_private()
{
	local ip="$1"		# FIXME! check if valid IPv4

	case "$ip" in
		192.168.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*|169.254.*|10.*|127.*)
			return 0		# RFC-1918
		;;
		100.[6-9]*|100.1[0-2]*)		# RFC-6598 / Carrier-Grade NAT = 100.64.0.0/10 ... 100.127.255.254/10
			explode $( echo "$ip" | tr '.' ' ' )
			test $2 -ge 64 -a $2 -le 127
			return $?
		;;
		*)
			return 1
		;;
	esac
}

_net_ip2dns()
{
	local ip="$1"
	local startparse last line error output do_olsr

	# root@box:~ nslookup 10.63.6.3
	# Server:    127.0.0.1			// these 2 lines are
	# Address 1: 127.0.0.1 localhost	// optional
	#
	# Name:      10.63.6.3
	# Address 1: 10.63.6.3 mid1.F36-Dach4900er-MESH		// hostname is missing if lookup fails

	# root@box:~ nslookup 10.63.222.1
	# Server:    (null)
	# Address 1: ::1 localhost
	# Address 2: 127.0.0.1 localhost
	#
	# Name:      10.63.222.1
	# Address 1: 10.63.222.1

	output="$( nslookup "$ip" 2>/dev/null || echo 'ERROR ERROR' )"
	explode $output

	case "$6" in
		*'mywifi'*|*'user-lan'*)
			do_olsr='true'
		;;
		*)
			if   [ "$1" = 'ERROR' ]; then
				do_olsr='true'
				error='true'
			elif _net ip4_is_private "$ip"; then
				do_olsr='true'
			fi
		;;
	esac

	[ -n "$do_olsr" ] && {
		[ -e '/var/run/hosts_olsr' ] && {
			while read -r line; do {
				# 10.63.194.131   mid1.Sommerbar-Kamera   # 10.63.194.161 (mid #1)
				explode $line

				case "$1" in
					"$ip")
						echo "$2"
						return 0
					;;
				esac
			} done <'/var/run/hosts_olsr'
		}

		if [ -n "$error" ]; then
			return 1
		else
			# use nslookup-output
			explode $output
		fi
	}

	while shift; do {
		case "$1" in
			'Name:')
				startparse='true'
			;;
			'Address')
				[ -n "$startparse" ] && {
					if [ -n "$4" ]; then
						echo "$4"
					else
						echo "$3"
					fi

					return 0
				}
			;;
			'')
				echo "$last"
				test "$last" != 'ERROR'
				return $?
			;;
		esac

		last="$1"
	} done

	return 1
}

_net_ismacaddress()
{
	case "$1" in
		[0-9a-f][0-9a-f][:-][0-9a-f][0-9a-f][:-]*)
		;;
		*)
			return 1
		;;
	esac
}

_net_ip2mac()		# works only for local/active IP's, but: maybe we want to "guess" using /etc/ethers...?
{			# TODO: send ping for onehop-neighs?
	local funcname='net_ip2mac'
	local get_ip="$1"
	local option="$2"	# string: 'lazy' (mostly for OLSR-neighs, where total exact match is not important)
	local mac=
	local tempfile="$TMPDIR/$funcname.$$"
	local line ip dev local_ip

	# this can be outdated, see http://www.intercity-vpn.de/files/openwrt/login_error.ejbw.wrong.mac.txt
	[ "$option" = 'lazy' ] && {
		cat "/tmp/IP2MAC_${get_ip}" 2>/dev/null
		return $?
	}

	# get mac from interface
	case "$get_ip" in
		'')
			return 1
		;;
		$WIFIADR)
			read -r mac 2>/dev/null <"/tmp/IP2MAC_${get_ip}" || mac="$( _net dev2mac "$WIFIDEV" )"
		;;
		$LANADR)
			read -r mac 2>/dev/null <"/tmp/IP2MAC_${get_ip}" || mac="$( _net dev2mac "$LANDEV" )"
		;;
		$WANADR)
			read -r mac 2>/dev/null <"/tmp/IP2MAC_${get_ip}" || mac="$( _net dev2mac "$WANDEV" )"
		;;
	esac

	# get mac from arp-cache
	[ -z "$mac" ] && {
		# correct is 'eth0.1'
		#
		# root@box: ip -oneline neigh show to 10.63.155.225
		# 10.63.155.225 dev eth0.1 lladdr b0:48:7a:c5:dc:bc REACHABLE
		# 10.63.155.225 dev wlan0 lladdr b0:48:7a:c5:dc:bc STALE
		#
		# root@box: grep b0:48:7a:c5:dc:bc /proc/net/arp 
		# 10.63.155.193    0x1         0x2         b0:48:7a:c5:dc:bc     *        wlan0
		# 10.63.155.225    0x1         0x2         b0:48:7a:c5:dc:bc     *        eth0.1
		# 10.63.2.37       0x1         0x2         b0:48:7a:c5:dc:bc     *        wlan0
		# 10.63.2.37       0x1         0x2         b0:48:7a:c5:dc:bc     *        eth0.1
		# 10.63.155.225    0x1         0x2         b0:48:7a:c5:dc:bc     *        wlan0
		# 10.63.2.35       0x1         0x2         b0:48:7a:c5:dc:bc     *        eth0.1

		ip -oneline neigh show to "$get_ip" >"$tempfile"	# FIXME! cannot be more than 1 line

		while read -r line; do {
			# /proc/net/arp sometimes shows '00:00:00:00:00:00' but 'ip' has this:
			# 10.63.42.125 dev wlan0 lladdr 64:09:80:7f:48:85 used 0/0/0 probes 6 FAILED
			explode ${line:-unset}
			ip="$1"
			dev="$3"
			mac="$5"

			case "$mac" in
				'00:00:00:00:00:00')
					mac=
					continue
				;;
				'24:a4:2c'*)
					# KOUKAAM / NetIO-230b
					[ -e '/tmp/WATCHDOG_TYPE1' ] || _sanitizer run "$ip-$mac" alphanum >'/tmp/WATCHDOG_TYPE1'
				;;
			esac

			if [ "$ip" = "$get_ip" ]; then
				local_ip="$( _net dev2ip "$dev" )"
				arping -c1 -s "$local_ip" -I "$dev" "$ip" >/dev/null && {
					_sanitizer run "$mac" lowercase >"/tmp/IP2MAC_$get_ip"
					break
				}
			else
				mac=
			fi
		} done <"$tempfile"
		rm "$tempfile"
	}

	# get mac from OLSR-neigh
	if [ -z "$mac" ]; then
		[ -e "/tmp/OLSR/isneigh_$get_ip" ] && {
			mac="$( _tool remote "$get_ip" ip2mac )"
			mac="$( _sanitizer run "$mac" mac )"

			[ -z "$mac" ] && {
				# LuCI-based:
				mac="$( _curl it "http://$get_ip/cgi-bin/luci/freifunk/status" | grep -- '-bssid">' | grep -v '>02:' )"
				mac="$( _sanitizer run "$mac" mac lowercase )"

				[ -z "$mac" ] && {
					# Sven-Ola based:
					mac="$( _curl it "http://$get_ip/cgi-bin-status.html" | grep ^'MAC:' )"
					mac="$( _sanitizer run "$mac" mac lowercase )"
				}
			}
		}

		if [ -n "$mac" ]; then
			echo "$mac" >"/tmp/IP2MAC_$get_ip"
		else
			# translate IPs from local interfaces (which are not in arp-cache), e.g. WIFI-2
			dev="$( ip -oneline address show to "$get_ip" | cut -d' ' -f2 )"
			# dev is empty, when IP is not local
			[ -n "$dev" ] && {
				mac="$( _net dev2mac "$dev" )" && {
					echo "$mac" >"/tmp/IP2MAC_${get_ip}"
				}
			}
		fi
	else
		echo "$mac" >"/tmp/IP2MAC_$get_ip"
	fi

	cat "/tmp/IP2MAC_$get_ip" 2>/dev/null
}

_net_dns2ip()
{
	local dns="$1"
	local go

	# explode $( nslookup host86-139-31-49.range86-139.btcentralplus.com )
	# Server: 127.0.0.1 Address 1: 127.0.0.1 localhost Name: host86-139-31-49.range86-139.btcentralplus.com Address 1: 86.139.31.49 host86-139-31-49.range86-139.btcentralplus.com
	explode $( nslookup "$dns" || echo 'ERROR ERROR' )

	while shift; do {
		case "$1" in
			'ERROR'|'')
				return 1
			;;
			'Name:')
				go='true'
			;;
			'Address:'|'Address')
				[ "$go" = 'true' ] || continue

				# 'Address 1: 84.38.67.43'
				# 'Address 1: 2a02:2e0:3fe:100::8 redirector.heise.de'
				# 'Address 2: 193.99.144.80 redirector.heise.de'
				# 'Address:    193.99.144.80'	// spaces on kernel 2.4
				[ "$1" = 'Address' ] && shift
				shift

				case "$1" in
					*':'*)
						# ignore IPv6
					;;
					*)
						echo "$1"
						return 0
					;;
				esac
			;;
		esac
	} done
}

_net_dev2name()
{
	local funcname='net_dev2name'
	local dev="$1"	# e.g. eth0.2 or pppoe-lan

	cat "/var/run/interfaces/dev2name_$dev" 2>/dev/null || {
		_log it $funcname daemon info "using fallback-parser for '$dev'"

		if _net dev_is_wifi "$dev"; then
			echo 'wifi'
		else
			case "$dev" in
				'pppoe-'*)
					# pppoe-lan -> lan
					echo "${dev#*-}"
				;;
			esac
		fi
	}
}

_net_dev2ip()			# only first ip
{
	local funcname='net_dev2ip'
	local dev="$1"
	local option="$2"	# 'ip'|'mask'|'debug'|'ip_but_noloopback'
	local mode="$3"		# 'CIDR'|'mask'

	local line ip_with_mask key

	[ -z "$dev" ] && return 1

	case "$option" in
		'ip_but_noloopback')
			line="$( ip -oneline -f inet address show dev "$dev" | grep -v 'inet 127\.' )"
		;;
		*)
			line="$( ip -oneline -f inet address show dev "$dev" )"
		;;
	esac

	explode ${line:-is_empty}

	case "$3" in
		'inet')
			key="$5"

			case "$key" in
				brd|scope)
					# e.g.:
					# 6: wlan0    inet 10.63.10.1/8 brd 10.255.255.255 scope global wlan0
					# 7: wlan0-1    inet 10.63.10.1/32 scope global wlan0-1
					ip_with_mask="$4"
				;;
				*)
					# e.g.:
					# 8: ppp0 inet 84.183.156.159 peer 217.0.116.17/32 scope global ppp0
					ip_with_mask="$6"
				;;
			esac
		;;
		*)
			if [ "$option" = 'debug' ];then
				_log it $funcname daemon info "[ERR] dev: $dev line: '$line'"
			else
				if [ $( _system uptime sec ) -lt 120 ]; then
					_log it $funcname daemon info "[ERR] dev: $dev line: '$line'"
				else
					case "$( ip -oneline link show dev "$dev" )" in
						*": $dev@"*)
#							_log it $funcname daemon debug "[OK] ignoring piggyback interface $dev@"
						;;
						*' state DOWN'*)
							_log it $funcname daemon debug "[ERR] dev: $dev state: down"
						;;
						*)
							case "$LANDEV" in
								"$dev")
								;;
								"$dev"*)
									_log it $funcname daemon debug "[OK] ignoring interface $dev (which belongs to lan: $LANDEV)"
									return 1
								;;
							esac

							case "$WANDEV" in
								"$dev")
								;;
								"$dev"*)
									_log it $funcname daemon debug "[OK] ignoring interface $dev (which belongs to wan: $WANDEV)"
									return 1
								;;
							esac

							_log it $funcname daemon alert "[ERR] dev: $dev line: '$line'"
							ip address show dev $dev >>$PERMLOG
						;;
					esac
				fi
			fi

			return 1
		;;
	esac

	case "$option" in
		'mask')
			case "$mode" in
				'CIDR')
					echo "${ip_with_mask%/*}"
				;;
				*)
					_net cidr2mask "${ip_with_mask#*/}"
				;;
			esac
		;;
		*)
			case "$mode" in
				'CIDR')
					echo "${ip_with_mask#*/}"
				;;
				'mask')
					_net cidr2mask "${ip_with_mask#*/}"
				;;
				*)
					echo "${ip_with_mask%/*}"
				;;
			esac
		;;
	esac
}

_net_dev2mac()
{
	local dev="${1:-empty_dev}"
	local line mac

	explode $( ip -oneline link show dev "$dev" )
	line="$*"
	mac="${line#*link/ether }"
	mac=${mac%% *}

	_net ismacaddress "$mac" && echo "$mac"
}

_net_devtype2symbol()
{
	case "$1" in
		'tunnel') printf '%s' '=' ;;
		'wifi') printf '%s' '~' ;;
		'unknown') printf '%s' '?' ;;
		*) printf '%s' '-' ;;
	esac
}

_net_dev_is_valid()
{
	local dev="$1"		# e.g. 'eth0.2'
	local line

	while read -r line; do {
		case "$line" in
			"$dev:"*|" $dev:"*|"  $dev:"*|"   $dev:"*|"    $dev:"*)
				return 0
			;;
		esac
	} done <'/proc/net/dev'

	return 1
}

_net_dev_type()		# out: string, "wifi/tunnel/wire"
{
	local dev="$1"
	local option="$2"	# short
	local out

	if   [ -z "$dev" ]; then
		out='unknown'
	elif _net dev_is_wifi "$dev" ; then
		out='wifi'
	elif _net dev_is_tuntap "$dev" ; then
		out='tunnel'
	else
		out='wire'
	fi

	if [ "$option" = 'short' ]; then
		_net devtype2symbol "$out"
	else
		echo "$out"
	fi
}

_net_dev_is_wifi()
{
	# case " $WIFI_DEVS " in
	# 	*" $dev "*)
	#		// is_wifi
	#	;;
	# esac
	case "$1" in
		br-mastergate)
			return 0	# FIXME/roaming
		;;
	esac

	grep -sq ^".*${1:-empty_devname}:" '/proc/net/wireless'
}

_net_dev_is_tuntap()
{
	local dev="$1"

	case "$dev" in
		'tun'*|'tap'*)
			return 0
		;;
		*)
			[ -d "/etc/tinc/$dev" ] && return 0
		;;
	esac

	return 1
}

_net_ip2dev()		# outputs real devname like 'br0' or 'wlan0-1'
{
	local funcname='net_ip2dev'	# TODO: make use of /tmp/CLIENTS_*?
	local ip="$1"
	local ip_found line devlist dev=

	case "$ip" in
		"$WIFIADR") dev="$WIFIDEV" ;;
		"$LANADR") dev="$LANDEV" ;;
		"$WANADR") dev="$WANDEV" ;;
		"$LOADR") dev="$LODEV" ;;
		*) false ;;
	esac && {
		echo "$dev"
		return 0
	}

	devlist="$( tail -n+3 /proc/net/dev | cut -d':' -f1 )"
	for dev in $devlist; do {
		ip_found="$( _net dev2ip "$dev" )"

		[ "$ip" = "$ip_found" ] && {
			echo "$dev"
			return 0
		}
	} done
	dev=

	while read -r line; do {
		case "$line" in
			"$ip "*)
				# 10.63.61.1  0x1  0x2  66:70:02:f3:90:6c  *  wlan1
				explode $line

				[ "$4" = '00:00:00:00:00:00' ] || {
					_log it $funcname daemon debug "try1: $6 <- $*"
					echo "$6"
					return 0
				}
			;;
		esac
	} done <'/proc/net/arp'

	# FIXME! we can be wrong:
	#
	# root@E2-ayse:~ _net ip2dev 10.63.22.65
	# ip -oneline route get 10.63.22.65
	# explode 10.63.22.65 via 10.63.22.89 dev eth0.2 src 10.63.20.89 \ cache
	#
	# it shows the routing-table (over wire), not the expected way over wifi

	# e.g.
	# 192.168.99.243 dev br-mybridge  src 192.168.99.1 \ cache
	# fe80::221:6aff:fe32:7c1c from :: dev eth0  src fe80::da5d:4cff:fe9c:2f1a  metric 0 \ cache
	explode $( ip -oneline route get "$ip" 2>/dev/null || echo 'ERROR ERROR' )

	while shift; do {
		case "$1" in
			'dev')
				dev="$2"
				# batman/macvlan-hack, maybe unneeded
				[ "$dev" = "gateway0" ] && dev="br-mybridge"
				echo "$dev"

				return 0
			;;
			'ERROR'|'metric'|'cache'|'')
				return 1
			;;
		esac
	} done
}

_net_local_inet_speed()
{
	local interface="$( _net local_inet_offer )"

	cat "/tmp/speed_inet_$interface"
}

_net_local_inet_offer_TEST()
{
	local input="$1"
	local f='_net_local_inet_offer'
	local in out wish

	die()
	{
		_log it TEST-$f daemon info "'$wish' != '$out' <= '$in'"
	}

	in='default via 192.168.1.1     dev   vlan1'
	wish='wan';	out="$( WANDEV='vlan1'  $f "$input" )"; test "$wish" = "$out" || die
	in='default via 191.255.255.1   dev   venet0'
	wish='venet0';	out="$( WANDEV='vlan1'  $f "$input" )"; test "$wish" = "$out" || die
	in='default via 217.0.116.253   dev   ppp0'
	wish='pppoe';	out="$( WANDEV='vlan1'  $f "$input" )"; test "$wish" = "$out" || die
	in='default dev tun0            scope link'
	wish='vpnc';	out="$( WANDEV='vlan1'  $f "$input" )"; test "$wish" = "$out" || die
	in='default dev venet0          scope link'
	wish='venet0';	out="$( WANDEV='vlan1'  $f "$input" )"; test "$wish" = "$out" || die
	in='default via 10.63.52.36     dev   br0'
	wish='lan';	out="$( LANDEV='br0'    $f "$input" )"; test "$wish" = "$out" || die
	in='default via 10.63.99.33     dev   eth0.1  metric 2    onlink'
	wish='lan';	out="$( LANDEV='eth0.1' $f "$input" )"; test "$wish" = "$out" || die
	in='default via 192.168.1.11    dev   eth0.1  src    192.168.1.2'
	wish='lan';	out="$( LANDEV='eth0.1' $f "$input" )"; test "$wish" = "$out" || die
	in='default via 192.168.1.1     dev   eth1    proto  static'
	wish='wan';	out="$( WANDEV='eth1'   $f "$input" )"; test "$wish" = "$out" || die
	in='default via 192.168.2.1     dev   br-mybridge'
	wish='false';	out="$( WANDEV=''       $f "$input" )"; test "$wish" = "$out" || die
}

_net_local_inet_offer()			# SENSE: check if default-route is local
{					# OUT1: string, false|wan|lan|pppoe
	local funcname='net_local_inet_offer'
	local option="$1"		# update_cache|cached|<testline> e.g. 'default via 192.168.1.1 dev vlan1'

	local cachefile="/tmp/$funcname-cache"
	local MODE='false'		# RC: true = inetoffer, false = no inetoffer
	local PHYDEV=0 METRIC=0 D=0 N=0 wan_proto cache

	case "$option" in
		'update_cache')
			_net local_inet_offer >"$cachefile"
			return 0
		;;
		'cached')
			[ -e "$cachefile" ] || _net local_inet_offer >"$cachefile"

			read -r cache <"$cachefile" && {
				echo "$cache"

				if [ "$cache" = 'false' ]; then
					return 1
				else
					return 0
				fi
			}
		;;
		'default '*)
			# local default_route="$option"
		;;
	esac

	wan_proto="$( uci -q get network.wan.proto )"
	[ "$wan_proto" = "pppoe" ] && {
		_log it $funcname daemon info "early_boot_estimation: pppoe"
		echo "pppoe"
		return 0
	}

	[ -e "$TMPDIR/NETPARAM" ] || {
		local WAN_GATEWAY="$( uci get network.wan.gateway )"
		[ -n "$WAN_GATEWAY" ] && {
			if [ "$WAN_GATEWAY" = "0.0.0.0" ]; then
				_nvram set wan_gateway
				_nvram set commit "config-mistake, unsetting wan-gateway which was '$WAN_GATEWAY'"
			else
				[ "$wan_proto" = "pppoe" ] && {
					_log it $funcname daemon info "early_boot_estimation: pppoe"
					echo "pppoe"
					return 0			# fixme!
				}

				_log it $funcname daemon info "early_boot_estimation: wan"
				echo "wan"
				return 0
			fi
		}

		[ -n "$( uci get network.lan.gateway )" ] && {		# IP
			_log it $funcname daemon info "early_boot_estimation: lan"
			echo 'lan'
			return 0
		}

#		/etc/init.d/S52vpnc_fff+ check && {
#			_log it $funcname daemon info "early_boot_estimation: tun"
#			echo "tun"
#			return 0
#		}

		# fixme! wan-dhcp?

		_log it $funcname daemon info "early_boot_estimation: false"
		echo "false"
		[ -z "$option" ] && return 1	# needed for debugging
	}

	local LAN_GATEWAY="$( uci -q get network.lan.gateway )"		# IP or 'true'
	[ -n "$LAN_GATEWAY" ] && {
		if [ "$LAN_GATEWAY" = 'true' ]; then
			_log it $funcname daemon info "lan-gateway enforced / true"
			echo 'lan'
			return 0
		else
			[ -z "$( ip route list exact '0.0.0.0/0' via $LAN_GATEWAY )" ] && {
				[ "$LAN_GATEWAY" = '0.0.0.0' ] || {
					_log it $funcname daemon info "alien_gateway '$LAN_GATEWAY': lan"
					echo 'lan'
					return 0
				}
			}
		fi
	}


#	[ -z "$default_route" ] && {
#		# FIXME! look for 'table all'?
#		default_route="$( ip route list exact '0.0.0.0/0' | head -n1 )"
#	}
#
#	explode $default_route
#	PHYDEV="$5"
#	METRIC="$7"
#	D="$3"
#	N="${7:-${4:-$2}}"
#	logger -s "7: $7 4: $4 2: $2 = $N option: $option"

	build_vars()
	{
		# FIXME! "table all"?
		ip route list exact '0.0.0.0/0' | head -n1 >"$TMPDIR/$funcname"

		while read -r N N D N PHYDEV METRIC N _ ; do {
			echo PHYDEV=$PHYDEV
			echo METRIC=$METRIC
			echo N=$N
			echo D=$D
		} done <"$TMPDIR/$funcname"
	}

	eval $( build_vars )

	[ "$METRIC" = "src" ] && METRIC=			# lan-offer via alias-interface
	[ "$N" = static ] && METRIC=

	if [ -z "$METRIC" ]; then				# found no metric = local inet-offer
		_log it $funcname daemon debug "PHYDEV: '$PHYDEV' METRIC: '$METRIC' N: '$N' D: '$D'"

		if [ -z "${PHYDEV}${METRIC}${N}" ]; then	# ip route list exact 0.0.0.0/0 -> "default via eth0" or similar
			[ "$LAN_GATEWAY" = '0.0.0.0' -o "$D" = 'br-mastergate' ] && {
				# FIXME! move to early-boot-estimation
				_nvram set lan_gateway
				_nvram set commit "config-mistake, unsetting lan-gateway which was '$LAN_GATEWAY'"

				_log it $funcname daemon alert "removing default via $D"
				ip route delete default via $D
			}
		else
			if   [ "$PHYDEV" = "$WANDEV" ]; then
				MODE="wan"
			elif [ "$PHYDEV" = "$LANDEV" ]; then
				MODE="lan"
			elif [ "$PHYDEV" = "$WIFIDEV" ]; then
				MODE="wifi"
			elif [ "$PHYDEV" = "br-mybridge" ]; then
				MODE="false"	# batman
			elif [ "$PHYDEV" = 'wwan0' ]; then
				MODE='wwan'
			else
				MODE="pppoe"	# && WANDEV=ppp0          # FIXME! this is not exact!
			fi

			[ "$PHYDEV" = "link" ] && {
				if   echo "$D" | grep -q "^tun[0-9]*" ; then
					MODE='tun'
				elif echo "$D" | grep -q "^tap[0-9]*" ; then
					MODE='tap'
				else
					MODE="$D"				# e.g. tun0 / vpnc
				fi
			}

			_log it $funcname daemon info "found local default-gateway over device '$PHYDEV' = '$MODE'"
		fi
	else
		if [ $N -eq 0 ]; then
			_log it $funcname daemon info "no local default-gateway, no default-gateway, no internet 8-("
		else
			_log it $funcname daemon info "no local default-gateway found, only $N hops away 8-)"
		fi
	fi

	echo "$MODE"

	[ "$MODE" = "false" ] && return 1	
	return 0
}

_net_inet_seems_stable()					# FIXME! also check path to gateway (add wireless costs/hops)
{								# FIXME! apply these checks regulary
	local FILE="/tmp/GATEWAY_CHECK_RECENT_COSTINT_ONLY"	# FIXME! test dns also?
	local funcname='net_inet_seems_stable'			# FIXME! use dnsfaker if unstable/unfake if stable
	local max_cost="$( uci -q get system.@monitoring[0].maxcost )"
	local file_broken="/tmp/$funcname"
	local routing_proto cost_integer
	local proto_uptime_ok="true"

	max_cost="${max_cost:-50000}"		# FIXME! correct would be to only take the weakest hop into account

	# with missing netifd we cannot change ESSID/restart AP-interfaces anyway
	# TODO: but we can show it in weblogin and redirect to fake-DNS
	[ -n "$LOWMEM" ] && return 0
	_system maintenance_window_active 'pppoe_reconnect' && return 0

	if pidof bat_events >/dev/null; then
		routing_proto='batman'
		[ $( _system uptime sec ) -gt 600 ] || proto_uptime_ok="false"
		FILE=
	else
		routing_proto='olsr'

		bool_true 'olsrd.@meta[0].no_watching' || {
			if _olsr uptime is_short; then
				proto_uptime_ok='false'
			else
				pidof olsrd >/dev/null || {
					_olsr daemon start "$funcname()"
					proto_uptime_ok='false'
				}
			fi
		}
	fi

	gateway_found()
	{
		local proto="$1"
		local gateway_check="$( uci -q get system.@weblogin[0].gateway_check )"

		case "$proto" in
			batman)
				local i=3
				local authserver="$( _weblogin authserver )"

				# special agreement: every node is a server (answers DHCP-requests)
				# and announces 512kbit, the real gateway announces 16mbit

				if batctl gateways | grep -q 'MBit'; then
					case "$CONFIG_PROFILE" in
						'apphalle'*)
							for i in $( seq "$i" -1 1 ); do {
								ping -q -c1 "$authserver" && return 0
							} done

							return 1
						;;
						*)
							return 0
						;;
					esac
				else
					# special: 16M/16M = real inet offer
					test "$( uci get batman-adv.bat0.gw_bandwidth )" = '16384kbit/16384kbit'
				fi
			;;
			olsr)
				[ -n "$gateway_check" ] && {
					_olsr gateways_get | grep -q ^"$( _sanitizer run "$gateway_check" 'escape_dots' )"$ || {
						# gateway do not see the other GW's
						_net local_inet_offer >/dev/null || {
							_log it $funcname daemon info "[ERR] gateway '$gateway_check' not found"
							return 1
						}
					}
				}

				test -n "$( ip route list exact '0.0.0.0/0' table main )"
			;;
		esac
	}

	[ "$proto_uptime_ok" = 'true' ] && {
		if gateway_found "$routing_proto"; then
			[ -e "$file_broken" ] && {
				rm "$file_broken"
				_log it $funcname daemon alert "unstable inet fixed after: $( _stopwatch stop "$funcname.broken" nolog,humanreadable )"

				if pidof bat_events >/dev/null; then
					# FIXME!
					_system reboot_safe "ssid_change"
				else
					_weblogin generate_prebuilt_splash_htmlfile persistent
					_wifi change_essid_ap original
				fi
			}
		else
			[ "$( uci -q get network.wwan.disabled )" = '0' ] && {
				_log it $funcname daemon alert "wwan: unstable inet, no default route in main-table"
				ifup wwan
				sleep 120	# FIXME!
			}

			if _watch counter "$file_broken" increment 1 max 5 ; then
				[ -e "$funcname.broken" ] || _stopwatch start "$funcname.broken" global
			else
				_wifi change_essid_ap
			fi

			_log it $funcname daemon info "unstable inet, no default route in main-table"
			return 1
		fi
	}

	[ -e "$FILE" -a "$proto_uptime_ok" = 'true' ] && {
		read -r cost_integer <"$FILE"

		test "$cost_integer" -gt $max_cost 2>/dev/null && {
			_log it $funcname daemon alert "unstable inet1, cost_int: '$cost_integer' > $max_cost"
			return 1
		}

		[ "$cost_integer" = "0" ] && {
			_log it $funcname daemon alert "unstable inet2, cost_int: '$cost_integer'"
			return 1
		}
	}

	return 0
}

_net_mac2ip()		# SENSE: get client-IP from different sources
{
	local mac="$1"
	local funcname="mac2ip"

	# 6 x hex-bytes + 5 x ':' = 17
	[ -z "$mac" -o ${#mac} -ne 17 ] && return 1

	_sanitizer include

	local MAC="$( _sanitizer run "${mac:-unset_mac}" lowercase )"
	local IP=
	local hostname=
	local COUNT=

	try_0()
	{
		case "$MAC" in
			02:00:ca:*|02:00:de:*)
				# we use selfdefined mac's on some batman-nodes, e.g.
				# 02:00:ca:b1:01:11 = node 111 (last 4 digits)
				# 02:00:ca:fe:02:22 = node 222
				# 02:00:ca:ff:00:33 = node  33
				# 02:00:de:ad:01:34 = node 134
				MAC="$( echo "$MAC" | cut -d':' -f5 )$( echo "$MAC" | cut -d':' -f6 )"

				MAC="${MAC#0}"          # e.g. 0002 -> 2
				MAC="${MAC#0}"
				MAC="${MAC#0}"

				IP="192.168.$MAC.1"
			;;
		esac
	}

	try_1()		# is filled during _netfiler_user_add() (macs are lowercase)
	{
		if [ -e "/tmp/MAC2IP_$MAC" ]; then
			read -r IP <"/tmp/MAC2IP_$MAC"
		else
			[ -e "/tmp/NETFILTER/MAC2IP/$MAC" ] && {
				read -r IP <"/tmp/NETFILTER/MAC2IP/$MAC"
			}
		fi
	}

	try_2()		# arp-cache (macs are lowercase)
	{
		local mac ip line

		while read -r line; do {
			explode $line
			ip="$1"
			mac="$( _sanitizer run "$4" lowercase )"

			[ "$MAC" = "$mac" ] && {
				IP="$ip"
				return
			}

		} done <'/proc/net/arp'
	}

	try_3()		# DHCP-leases (macs are lowercase)
	{
		local leasefile="$( _net dhcp_lease_filename )"

		[ -e "$leasefile" ] && {
			IP="$( sed -e "/$MAC/!d" -ne 's/^.* ..:..:..:..:..:.. \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' "$leasefile" )"
		}
	}

	try_4()		# /etc/ethers -> /etc/local.hosts (macs are lowercase)
	{
		hostname="$( sed -n "s/^$MAC \(.*\)/\1/p" /etc/ethers 2>/dev/null )"
		[ -n "$hostname" ] && IP="$( sed -n "/$hostname/s/^\([0-9\.]*\) ${hostname}.*/\1/p" /etc/local.hosts )"
	}

	for COUNT in 0 1 2 3 4 ; do {
		try_${COUNT}

		[ -n "$IP" ] && {
			echo "$MAC" >/tmp/IP2MAC_$IP
			echo "$IP"
			return 0
		}
	} done

	_log it $funcname daemon info "could not get ip for mac $MAC"
	return 1
}

_net_mac2hostname ()
{
	local MAC="$1"

	local NAME="$( grep -i $MAC /etc/ethers | sed -n 's/^..:..:..:..:..:.. \(.*\)-.*-.*\..*$/\1/p' )"	# cutting off e.g. "-lan1-n364.domain"
	echo ${NAME:=anonym}
}

_net_mac2dev()
{
	local get_mac="$1"
	local exact="$2"		# e.g. for arp_permanent we need 'br-mybridge' and not 'wlan1'
	local mac dev

	_sanitizer include

	while read -r _ _ _ mac _ dev; do {
		mac="$( _sanitizer run "$mac" lowercase )"

		[ "$get_mac" = "$mac" ] && {
			[ -n "$exact" ] || {
				case "$dev" in
					'br-mybridge'|'gateway0')
						for dev in $WIFI_DEVS; do {
							iw dev "$dev" station get "$mac" 2>/dev/null >/dev/null && {
								break
							}
						} done
					;;
				esac
			}

			echo "$dev"
			return 0
		}

	} done <'/proc/net/arp'

	return 1
}

_net_mac2media()
{
	local MAC="$1"				# ARG1: (string) mac-address
	local SHORT="$2"			# ARG2: (string) keyword "short" (optional)
	local OUT=0				# OUT1: (string) wifi,wire OR ~,-
	local DEV="$( _net mac2dev "$MAC" )"

	  if [ "$DEV" = "$WIFIDEV" ]; then
	  	OUT=wifi
	elif uci get system.@ethers[0].wifi | grep -qi $MAC ; then
		OUT=wifi
	elif grep -sq ^"$( _sanitizer run "$( _net mac2ip $MAC )" escape_dots );" /tmp/CLIENTS_WIFI ; then
		OUT=wifi
	else
		OUT=wire		# fixme! this can also be guessed!
	fi

	[ -n "$SHORT" ] && OUT="$( _net devtype2symbol $DEV )"

	printf '%s' "$OUT"
}

_net_arp_permanent()
{
	local FUNC="net_arp_permanent"
        local IP="$1"
        local MAC="$( _sanitizer run "$2" lowercase )"
        local FORCE="$3"				# or <dev>
	local nudmode="${4:-permanent}"			# or 'reachable'
	local MODE LINE DEV dev_keyword=''

	case "$IP" in
		'100.'*)
			return 0	# ugly: do not for roaming
		;;
	esac

        _log it $FUNC daemon info "IP: '$IP' MAC: '$MAC' FORCE: '$FORCE' nudmode: '$nudmode'"

	# see dhcp-script
	[ "$MAC" = '00:00:00:00:00:00' ] && return 1

	if _net dev_is_valid "$FORCE"; then
		DEV="$FORCE"
		dev_keyword="$DEV (user input)"
	else
		DEV="$( _net mac2dev "$MAC" )"		# fixme! probe up to 3 times?
	fi

	LINE="$( ip neigh show to "$IP" dev "$DEV" 2>/dev/null )"
	echo "$LINE" | grep -Fi -q " $nudmode" && {
		_log it $FUNC daemon debug "[OK] already nud '$nudmode' on dev '$DEV'"
		return 0
	}

	if [ -n "$LINE" ]; then
		MODE='change'
	else
		MODE='add'
	fi

 	if [ -z "$DEV" ]; then
		_log it $FUNC daemon info "not in neigh-list, probing"

 		  if [ "$FORCE" = 'wifi' ]; then
			dev_keyword="wifi (forced)"
			DEV="$WIFIDEV"
 		elif [ "$( _net mac2media $MAC )" = 'wire' ]; then		# why a 2nd try? -> checked: is needed somethimes
			dev_keyword="wire (detected at 2nd try)"
			DEV="$LANDEV"
 		else
			dev_keyword="wifi (defaulting)"
			DEV="$WIFIDEV"
 		fi
 	else
		[ -z "$dev_keyword" ] && dev_keyword="$DEV (autodetected)"
 	fi

	_log it $FUNC daemon info "detected physical-device ${dev_keyword:-unknown}: ip neigh $MODE $IP dev $DEV lladdr $MAC nud $nudmode"
	ip neigh $MODE $IP dev $DEV lladdr $MAC nud "$nudmode" 2>/dev/null || return $?

	[ -e "$TMPDIR/OLSR/fixed_arp_$IP" ] && rm "$TMPDIR/OLSR/fixed_arp_$IP"
	return 0
}

_net_mask2cidr()	# see https://lists.openwrt.org/pipermail/openwrt-devel/2015-June/033540.html
{			# e.g.: 255.255.255.0 -> 24
	local x=${1##*255.}
	local allones=$(( (${#1} - ${#x}) * 2 ))
	local tbl='0^^^128^192^224^240^248^252^254^'
	x=${tbl%%${x%%.*}*}
	echo $(( allones + (${#x}/4) ))
}

_net_cidr2mask()	# OUT1: string
{
	local o

	case "$1" in
		31) o=255.255.255.254 ;;
		30) o=255.255.255.252 ;;
		29) o=255.255.255.248 ;;
		28) o=255.255.255.240 ;;
		27) o=255.255.255.224 ;;
		26) o=255.255.255.192 ;;
		25) o=255.255.255.128 ;;
		24) o=255.255.255.0 ;;
		23) o=255.255.254.0 ;;
		22) o=255.255.252.0 ;;
		21) o=255.255.248.0 ;;
		20) o=255.255.240.0 ;;
		19) o=255.255.224.0 ;;
		18) o=255.255.192.0 ;;
		17) o=255.255.128.0 ;;
		16) o=255.255.0.0 ;;
		15) o=255.254.0.0 ;;
		14) o=255.252.0.0 ;;
		13) o=255.248.0.0 ;;
		12) o=255.240.0.0 ;;
		11) o=255.224.0.0 ;;
		10) o=255.192.0.0 ;;
		 9) o=255.128.0.0 ;;
		 8) o=255.0.0.0 ;;
		 7) o=254.0.0.0 ;;
		 6) o=252.0.0.0 ;;
		 5) o=248.0.0.0 ;;
		 4) o=240.0.0.0 ;;
		 3) o=224.0.0.0 ;;
		 2) o=192.0.0.0 ;;
		 1) o=128.0.0.0 ;;
		 *) o=255.255.255.255 ;;
	esac

	printf '%s' "$o"
}

_net_active_ap_devices()	# TODO: add linefeed, so 'read X <FILE' will return 0
{
	local dev

	grep ^'interface=' /var/run/hostapd-phy[0-3].conf | cut -d'=' -f2 | while read -r dev; do printf '%s' " $dev "; done
}
